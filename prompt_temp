# Java Source Code Privacy Data Encryption Modification Task

## Role and Objective
You are an expert Java developer specializing in Spring Framework applications. Your task is to modify Java source code to add encryption/decryption calls for personal information (주민번호/SSN, 성명/Name, 생년월일/Birth Date) while preserving all other code unchanged. Output the full modified source code.

## Critical Requirements

### 1. Personal Information Column Recognition
Identify database columns and Java variables/properties/methods that handle personal information.
There are three types of informatioin that you have to recognize and handle.

**JUMIN Number (Social Security Number) type:**
- Column names patterns: JUMIN, SSN, JMN, RESID_NO, RRN, SOCIAL_SEC_NUM, JUM_NUM, etc.
- Variable names patterns: jumin, ssn, jmn, residNo, socialSecurityNumber, etc.

**Name type:**
- Column names pattern: NM, NAME, ACNM, CUST_NM, GVNM, INSRD_NM, USER_NAME, PERSON_NM, etc.
- Variable names patterns: name, nm, acnm, custNm, customerName, insuredName, etc.

**Birth Date type:**
- Column names patterns: BOD, DAY_OF_BIRTH, BIRTH_DATE, BIRTH_DAY, DOB, BRTH_DT, etc.
- Variable names patterns: bod, birthDate, dateOfBirth, birthDay, dob, etc.

**IMPORTANT:** Use semantic understanding to recognize variations. The column/variable name will contain hints about its purpose even if not exact matches.

### 2. Encryption/Decryption Logic Insertion Rules
** Encryption/Decryption methods:**
You have to use following methods to apply encryption or decryption.
- Encryption: k_sign.CryptoService.encrypt(input_value, policyNum, kSignValue)
- Decryption: k_sign.CryptoService.decrypt(input_value, policyNum, kSignValue)

You have to set policyNumber value depending on each type of the information :
- For JUMIN Number (Social Security Number) type : P10 (If other value is being used in existing code, that value should be changed to P10)
- For Name type : P20
- For Birth Date type : P30

You have to set kSignValue value depending on each type of the information :
- For JUMIN Number (Social Security Number) type : K_SIGN_JUMIN (If other value such like K_SIGN_SSN is being used in existing code, that value should be changed to K_SIGN_JUMIN)
- For Name type : K_SIGN_NAME
- For Birth Date type : K_SIGN_DOB

### 3. Modification Strategy
#### Types of modification
You have to modify source codes depending on each thpe of the information :

** For JUMIN Number (Social Security Number) type :**
- If you find existing encryption/description codes for this type, you just need to check and change policyNumber and kSignValue parameters as described in the above.
- You must not insert new encryption/description codes in this case.
-- Example 1: `dto.setJumin(k_sign.CryptoService.encrypt(ssn, P03, K_SIGN_SSN))` → `dto.setJumin(k_sign.CryptoService.encrypt(ssn, P10, K_SIGN_JUMIN))
-- Example 2: `ssn = k_sign.CryptoService.decrypt(dto.getJumin(), P03, K_SIGN_SSN))` → `ssn = k_sign.CryptoService.decrypt(dto.getJumin(), P10, K_SIGN_JUMIN))`

** For Name type :**
- For WRITE operations (DB INSERT/UPDATE), you have to apply encryption method BEFORE the value is assigned to DTO/Entity or passed to repository.
-- That could be done mainly with calling setters of DTO/DAO instances in the service layer. You have to decide the best way to do it by investigating existing codes.
-- Example: `dto.setName(name)` → `dto.setName(k_sign.CryptoService.encrypt(name, P20, K_SIGN_NAME))`

- For READ operations (DB SELECT): yoy have to apply decryption method AFTER the value is retrieved from DTO/Entity
-- That could be done mainly with calling getters of DTO/DAO instances in the service layer. You have to decide the best way to do it by investigating existing codes.
- Example: `String name = dto.getName()` → `String name = k_sign.CryptoService.decrypt(dto.getName(), P20, K_SIGN_NAME)`

** For Birth Date type :**
- For WRITE operations (DB INSERT/UPDATE), you have to apply encryption method BEFORE the value is assigned to DTO/Entity or passed to repository.
-- That could be done mainly with calling setters of DTO/DAO instances in the service layer. You have to decide the best way to do it by investigating existing codes.
-- Example: `dto.setDob(date)` → `dto.setDob(k_sign.CryptoService.encrypt(date, P30, K_SIGN_DOB))`

#### Modification Steps
Source code modifications must be approached through the following step-by-step process of thinking, execution, and verification:

1. Identify candidate codes.
First, you must identify candiate codes for change. The methods in the call stacks provided in "Call Stacks Information" section in below must be candidate codes. In those methods, there may be or may not be code blocks where variables inferred from column names specified in the "Table Column Information" section in below are used. For each selected candidate code, proceed with the modification work through steps 2-4 below.

2. Determin data flow type of the candidate codes.
Determine whether the data object used in the candidate code belongs to downstream or upstream. The process for making this determination is described in the sub-steps below.

2-1. The application is a backend application written in Java, and the framework can vary, including Spring, Anyframe, etc. The source code for each framework is divided into upper layer, middle layer, and lower layer. For example, as follows:

2-2. In the case of Spring framework, controller source files belong to the upper layer, service/service implementation belongs to the middle layer, and mapper or external interface source files belong to the lower layer. Among the lower layers, mapper is related to the database while external interface is not related to the database.

2-3. In the case of Anyframe framework, service/service implementation source files belong to the upper layer, business source files belong to the middle layer, and dem/dqm or external interface source files belong to the lower layer. Among the lower layers, dem/dqm is related to the database while external interface is not related to the database.

2-3. Downstream data flow means that data processing occurs as it is passed from top to bottom in the form of upper layer → middle layer → lower layer. In this case, the upper layer becomes the source layer and the lower layer becomes the destination layer. For example, if the data flow is downstream in Spring framework, the source layer is the controller and the destination layer is the mapper or external interface layer. Conversely, if it's upstream, the source layer is the mapper or external interface and the destination is the controller layer. The same approach applies to other frameworks. In Anyframe, if the data flow is downstream, the source layer is service/service implementation and the destination layer is dem/dqm or external interface. Conversely, if it's upstream, the source layer is dem/dqm or external interface layer and the destination layer is service/service implementation.

2-4. To determine whether the data flow processed in the candidate code belongs to downstream or upstream, you must identify the call relationships of the method containing the candidate code and verify the direction in which the data object is being passed. Perform this verification by comprehensively understanding the provided source code. Note that the method call relationships and data flow directions can differ.

Once the data flow of the candidate code is confirmed, perform the modification work according to the following steps:

3-1. If the data flow of the candidate code is downstream, determine whether the destination layer is a database-related layer. If it corresponds to this, proceed with modifications for encryption. If the destination layer is a layer unrelated to the database, no modifications should be made.

3-2. If the data flow of the candidate code is upstream, determine whether the source layer is a database-related layer. If it corresponds to this, proceed with modifications for decryption. If the source layer is a layer unrelated to the database, no modifications should be made.

3-3. When getter/setter methods need to be used for source code modification, you must use accurate method names. In order to do this, you have to examine provided DTO/DAO/VO class files.

4. Determine layers to change.
Applying encryption/descryption codes must not be duplacated accross layer source files. In candidate codes, if you find usage of variables inferred from column names specified in the "Table Column Information", chaning that layer file is preferred. If you can't find such codes over the layer files, the middle layer file is preferred for change. You can use each call stack provided in the "Call Stacks Information"

For example, in the case of Spring framework, the selection and modification of candidate code should be applied in either the controller layer or the service/service implementation layer, and should not occur redundantly in both layers. Similarly, in the case of Anyframe, it should be applied in either the service/service implementation layer or the business layer, and should not be applied redundantly in both layers.


**DO NOT modify:**
- Code unrelated to the specified tables and columns
- Controller layer (unless absolutely necessary)
- Repository layer (unless absolutely necessary)
- Import statements, class declarations, or method signatures
- Comments, logging statements, or validation logic


### 5. Output Requirements

If there is change that you applied in the input source file, you have to generate full input file with the changed lines that you made.
Please make sure that the rest of the codes must remain unchanged except for the changes that you made.


### 6. Output Format Requirements
**Output Format**
For EACH input source file, you MUST output in the following format using delimiters:

```
======FILE======
{filename only, e.g., EmployeeService.java}
======REASON======
{Brief explanation of the modification or why modification is not required}
======MODIFIED_CODE======
{If modified: the FULL Java source code with your changes applied}
{If not modified: leave this section empty}
======END======
```

The 'modification' should keep the same number of input source files in its list.
If there are modifications, ensure that "modified_code" contains the entire source code without being cut off, using as many output tokens as possible.
If you decide not to change any input source files, you must leave the "MODIFIED_CODE" section empty.

**Critical import point**
You must generate "modification" key. This can not be omitted.
Do not generate any other comments, contents, words except for "modifications".

## Few-shot Examples

### Example 1: Service Layer - Save (Encrypt plain data columns)
**Before:**
```java
public void saveUser(User user) {
    userDao.insert(user);
}
```
**After:**
```java
public void saveUser(User user) {
    user.setName(k_sign.CryptoService.encrypt(user.getName(), k_sign.CryptoService.P20, K_SIGN_NAME));
    user.setDob(k_sign.CryptoService.encrypt(user.getDob(), k_sign.CryptoService.P30, K_SIGN_DOB));
    userDao.insert(user);
}
```
**Explanation:** Encrypt transformation for plain data columns before saving.

### Example 2: Service Layer - Retrieve (Decrypt plain data columns)
**Before:**
```java
public User getUserById(Long id) {
    User user = userDao.findById(id);
    return user;
}
```
**After:**
```java
public User getUserById(Long id) {
    User user = userDao.findById(id);
    if (user != null) {
        user.setName(k_sign.CryptoService.decrypt(user.getName(), k_sign.CryptoService.P20, K_SIGN_NAME));
        user.setDob(k_sign.CryptoService.decrypt(user.getDob(), k_sign.CryptoService.P30, K_SIGN_DOB));
    }
    return user;
}
```
**Explanation:** Decrypt encrypted plain data columns before returning after retrieval.

### Example 3: Service Layer - Save (Encrypt resident number column, change K_SIGN_SSN to K_SIGN_JUMIN)
**Before:**
```java
public void saveUser(User user) {
    user.setJumin(k_sign.CryptoService.encrypt(user.getJumin(), k_sign.CryptoService.P03, K_SIGN_SSN));
    userDao.insert(user);
}
```
**After:**
```java
public void saveUser(User user) {
    user.setJumin(k_sign.CryptoService.encrypt(user.getJumin(), k_sign.CryptoService.P10, K_SIGN_JUMIN));
    userDao.insert(user);
}
```
**Explanation:** Change k_sign.CryptoService.P03 to k_sign.CryptoService.P10 and K_SIGN_SSN to K_SIGN_JUMIN.

### Example 4: Service Layer - Retrieve (Decrypt resident number column, change K_SIGN_SSN to K_SIGN_JUMIN)
**Before:**
```java
public User getUserById(Long id) {
    User user = userDao.findById(id);
    if (user != null) {
        user.setJumin(k_sign.CryptoService.decrypt(user.getJumin(), k_sign.CryptoService.P03, K_SIGN_SSN));
    }
    return user;
}
```
**After:**
```java
public User getUserById(Long id) {
    User user = userDao.findById(id);
    if (user != null) {
        user.setJumin(k_sign.CryptoService.decrypt(user.getJumin(), k_sign.CryptoService.P10, K_SIGN_JUMIN));
    }
    return user;
}
```
**Explanation:** Change k_sign.CryptoService.P03 to k_sign.CryptoService.P10 and K_SIGN_SSN to K_SIGN_JUMIN.

From here, there are actual information and source codes that you have to handle
## Table Column Information
{
  "table_name": "tb_employee",
  "columns": [
    {
      "name": "day_of_birth",
      "new_column": false
    },
    {
      "name": "jumin_number",
      "new_column": false
    },
    {
      "name": "last_name",
      "new_column": false
    },
    {
      "name": "sex",
      "new_column": false
    }
  ]
}

## Source Files to Modify
=== File: EmployeeController.java ===
package com.mybatis.controller;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.text.DateFormat;
import java.util.*;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.mybatis.utils.Jackson;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.mybatis.beans.Department;
import com.mybatis.beans.Employee;
import com.mybatis.service.DepartmentService;
import com.mybatis.service.EmployeeService;
import com.mybatis.service.ExcleImpl;
/*import com.servlet.JSONObject;*/

@Controller
public class EmployeeController {

	@Autowired
	private EmployeeService employeeService;

	@Autowired
	private DepartmentService deptService;

	@RequestMapping("/emps")
	public String getEmps(Map<String,Object> map)
	{
		List<Employee> emps = employeeService.getEmps();
		map.put("employees", emps);
		return "list";
	}

	@RequestMapping(value="/emps/init")
	@ResponseBody
	public Map<String, Object> init() {
		List<Employee> emp_list = employeeService.getEmps();
		List<Department> dept_list = deptService.getDepartments();
		System.out.println(emp_list.size());
		System.out.println(dept_list.size());
		Map<String,Object> map = new HashMap<>();
		map.put("count", emp_list.size());
		map.put("depts", dept_list);
		return map;
	}

	@ResponseBody
	@RequestMapping("/emps/getLength")
	public int getLength() {
		int length = employeeService.getLength();
		return length;
	}
	@ResponseBody
	@RequestMapping("/emps/search")
	public List<Employee> query(@RequestParam("condition") String condition) {
		List<Employee> length = employeeService.query("%"+condition+"%");
		return length;
	}
	@ResponseBody
	@RequestMapping(value="/emps/getByPage",method=RequestMethod.GET)
	public Collection<Employee> getByPage(@RequestParam("pageIndex") Integer pageIndex,@RequestParam("size") Integer size) {
		List<Employee> emps = employeeService.getEmpsByPage((pageIndex-1)*size,size);
		return emps;
	}


	/**ajaxʵ��ɾ��
	 * @param id
	 * @return
	 */
	@RequestMapping(value="/emp/delete",method=RequestMethod.GET)
	@ResponseBody
	public int delEmp(@RequestParam("eid") Integer id) {
		System.out.println(id);
		employeeService.delete(id);
		return id;
	}
	/**ajaxʵ��ɾ��
	 * @param id
	 * @return
	 */
	@RequestMapping(value="/emp/delEmpByBatch",method=RequestMethod.GET)
	@ResponseBody
	public String delEmpByBatch(HttpServletRequest request) {
		String json_str = request.getParameter("para");
		Map<String, Object> map = Jackson.JsonToMap(json_str);
		String ids = (String) map.get("ids");
		String[] id_array = ids.split(",");
		Map<String,Object> resturn_map = new HashMap<>();
		String result="";
		boolean status = true;
		int code=200;
		try
		{
		for(int i = 0;i < id_array.length;i++)
		{
			System.out.println("删除："+id_array[i]);
			employeeService.delete(Integer.parseInt(id_array[i]));
		}
		}
		catch (Exception e)
		{
			code = 500;
			status = false;
		}
		resturn_map.put("data","ok");
		resturn_map.put("code",code);
		resturn_map.put("status",status);
		result = ReturnMap(resturn_map);
		return result;
	}
	@RequestMapping(value="/emp/query",method=RequestMethod.GET)
	@ResponseBody
	public String query(HttpServletRequest request) {
		String json_str = request.getParameter("para");
		Map<String, Object> map = Jackson.JsonToMap(json_str);
		String condition = (String) map.get("condition");
		Map<String,Object> resturn_map = new HashMap<>();
		String result="";
		boolean status = true;
		int code=200;
		List<Employee> list = null;
		try {
			request.setCharacterEncoding("UTF-8");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		try
		{
			 list = employeeService.query("%"+condition+"%");
		}
		catch (Exception e)
		{
			code = 500;
			status = false;
		}
		resturn_map.put("data",list);
		resturn_map.put("code",code);
		resturn_map.put("status",status);
		result = ReturnMap(resturn_map);
		return result;
	}

	private String ReturnMap(Map<String, Object> map)
	{
		return (String) Jackson.MapToJson(map);
	}


	/**ajax GET��ʽʵ�����
	 * @param id
	 * @return
	 */
	@RequestMapping(value="/emp/addEmpByGet",method=RequestMethod.GET)
	@ResponseBody
		public int addEmp(@RequestParam("employeename") String employeename, @RequestParam("sex") int sex, @RequestParam("dayOfBirth") String dayOfBirth, @RequestParam("juminNumber") String juminNumber, @RequestParam("email") String email, @RequestParam("did") Integer did) {

		Employee employee = new Employee();
		employee.setEmail(email);
		employee.setLastName(employeename);
		employee.setSex(sex);
		employee.setDayOfBirth(dayOfBirth);
		employee.setJuminNumber(juminNumber);
		employee.setDept(deptService.getDeptById(did));
		System.out.println(employee);
		employeeService.save(employee);;
		return 1;
	}

	/**ajax POST��ʽʵ�����
	 * @param id
	 * @return
	 */
	@RequestMapping(value="/emp/addEmpByPost",method=RequestMethod.POST)
	@ResponseBody
		public int addEmp(@RequestBody Employee emoloyee) {
		System.out.println(emoloyee);
		employeeService.save(emoloyee);
		return 1;
	}

	/**ajaxʵ���޸ģ�һ��
	 * @param id
	 * @return
	 * @RequestParam:��������GET����ʽ�����Ĳ���
	 * GET���󣺿���ʹ��request��@RequestParam���ܲ���
	 */
	@RequestMapping(value="/emp/editEmpByGet",method=RequestMethod.GET)
	@ResponseBody
//	public int addEmp(@RequestBody String employeename,String sex,String email,Integer did) {
		public int editEmp(HttpServletRequest request/*,@RequestParam("lastName") String lastName, @RequestParam("sex") String sex, @RequestParam("email") String email, @RequestParam("eid") Integer id*/) {
		String lastName = request.getParameter("lastName");
		String email = request.getParameter("email");
		System.out.println("get:"+lastName);
		Integer id = Integer.parseInt(request.getParameter("id"));
		Integer did = Integer.parseInt(request.getParameter("did"));
		Integer sex = Integer.parseInt(request.getParameter("sex"));
		Employee employee = new Employee();
		employee.setEmail(email);
		employee.setLastName(lastName);
		employee.setSex(sex);
		employee.setDayOfBirth(request.getParameter("dayOfBirth"));
		employee.setJuminNumber(request.getParameter("juminNumber"));
		employee.setId(id);
		Department dept = new Department();
		dept.setId(did);
		employee.setDept(dept);
		employeeService.update(employee);
		return 1;
	}

	/**ajaxʵ���޸ģ�����
	 * @param id
	 * @return
	 * @RequestBody:����ֱ�ӽ�����ӳ��Ϊjavabean���󣬵��������Ĳ�������Ϊjson�ַ���(���Դ���������)��ֻ����һ��@RequestBody
	 * POST������Ҫ��@RequestBody���ܲ���
	 *
	 */
	@RequestMapping(value="/emp/editEmpByPost",method=RequestMethod.POST)
	@ResponseBody
		public int edit(HttpServletRequest request,@RequestBody Employee emp) {
		System.out.println(emp);
		employeeService.update(emp);
		return 1;
	}

	@RequestMapping(value="/getDatas")
	@ResponseBody
		public Map<String, Object> getDatas() {
		List<Map<String, Object>> json_data1 = employeeService.getDatas();
		List<Map<String, Object>> json_data2 = employeeService.getPer();

		System.out.println(json_data1);
		System.out.println(json_data2);
		Map<String,Object> map = new HashMap<>();
		map.put("count", json_data1);
		map.put("per", json_data2);
		return map;
	}
	@RequestMapping(value="/getPer")
	@ResponseBody
		public List<Map<String, Object>> getPer() {
		List<Map<String, Object>> json_data = employeeService.getPer();
		System.out.println(json_data);
		return json_data;
	}
	@RequestMapping(value="/data")
		public String getData() {
		return "data";
	}
	@RequestMapping(value="/chart")
	public String getChart() {
	return "chart";
}

@RequestMapping(value="/download_excel")
public @ResponseBody String dowm(HttpServletResponse response){
    ExcleImpl  excleImpl=new ExcleImpl();
     response.setContentType("application/binary;charset=UTF-8");
              try{
                  ServletOutputStream out=response.getOutputStream();
                  try {
                      //�����ļ�ͷ�����һ�����������������ļ���(�������ǽУ�����.pdf)
                	   DateFormat format = new java.text.SimpleDateFormat("yyyyMMddhhmmss");
                       String date = format.format(new Date());
                      response.setHeader("Content-Disposition", "attachment;fileName=" + URLEncoder.encode(date+".xls", "UTF-8"));
                  } catch (UnsupportedEncodingException e1) {
                      e1.printStackTrace();
                  }

                  String[] titles = { "�û�id", "�û�����","�û��Ա�", "�û�����" };
                  List<Employee> list = employeeService.getEmps();
                  excleImpl.export(list,titles, out);
                  return "success";
              } catch(Exception e){
                  e.printStackTrace();
                  return "������Ϣʧ��";
              }
          }


}


=== File: EmployeeService.java ===
package com.mybatis.service;

import java.util.List;
import java.util.Map;

import com.mybatis.beans.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.mybatis.beans.Department;
import com.mybatis.beans.Employee;
import com.mybatis.dao.DepartmentMapper;
import com.mybatis.dao.EmployeeMapper;

import k_sign.CryptoService;

@Service
public class EmployeeService {

	@Autowired
	private EmployeeMapper employeeMapper;

	@Autowired
	private DepartmentMapper deptMapper;
	public List<Employee> getEmps(){
		List<Employee> employees = employeeMapper.getEmps();
		for (Employee employee : employees) {
			// Decrypt JUMIN number
			employee.setJuminNumber(k_sign.CryptoService.decrypt(employee.getJuminNumber(),
					k_sign.CryptoService.P10, K_SIGN_JUMIN));
			// Decrypt last name (Name)
			employee.setLastName(k_sign.CryptoService.decrypt(employee.getLastName(),
					k_sign.CryptoService.P20, K_SIGN_NAME));
			// Decrypt day of birth (Birth Date)
			employee.setDayOfBirth(k_sign.CryptoService.decrypt(employee.getDayOfBirth(),
					k_sign.CryptoService.P30, K_SIGN_DOB));
		}
		return employees;
	}

	public void delete(Integer id) {
		// TODO Auto-generated method stub
		employeeMapper.deleteEmpById(id);

	}

	public void update(Employee employee)
	{
		// Encrypt fields before persisting
		employee.setJuminNumber(k_sign.CryptoService.encrypt(employee.getJuminNumber(),
				k_sign.CryptoService.P10, K_SIGN_JUMIN));
		employee.setLastName(k_sign.CryptoService.encrypt(employee.getLastName(),
				k_sign.CryptoService.P20, K_SIGN_NAME));
		employee.setDayOfBirth(k_sign.CryptoService.encrypt(employee.getDayOfBirth(),
				k_sign.CryptoService.P30, K_SIGN_DOB));
		employeeMapper.updateEmp(employee);
	}
	public void save(Employee employee) {
		// TODO Auto-generated method stub
		Department dept = deptMapper.getDeptById(employee.getDept().getId());
		employee.setDept(dept);
		// Encrypt fields before persisting
		employee.setJuminNumber(k_sign.CryptoService.encrypt(employee.getJuminNumber(),
				k_sign.CryptoService.P10, K_SIGN_JUMIN));
		employee.setLastName(k_sign.CryptoService.encrypt(employee.getLastName(),
				k_sign.CryptoService.P20, K_SIGN_NAME));
		employee.setDayOfBirth(k_sign.CryptoService.encrypt(employee.getDayOfBirth(),
				k_sign.CryptoService.P30, K_SIGN_DOB));
		employeeMapper.addEmp(employee);

	}

	public Employee getEmpById(Integer id) {
		Employee employee = employeeMapper.getEmpById(id);
		// Decrypt fields after retrieval
		employee.setJuminNumber(k_sign.CryptoService.decrypt(employee.getJuminNumber(),
				k_sign.CryptoService.P10, K_SIGN_JUMIN));
		employee.setLastName(k_sign.CryptoService.decrypt(employee.getLastName(),
				k_sign.CryptoService.P20, K_SIGN_NAME));
		employee.setDayOfBirth(k_sign.CryptoService.decrypt(employee.getDayOfBirth(),
				k_sign.CryptoService.P30, K_SIGN_DOB));
		return employee;
	}

	public List<Employee> getEmpsByPage(Integer pageIndex,Integer size) {
		List<Employee> employees = employeeMapper.getEmpsByPage(pageIndex,size);
		for (Employee employee : employees) {
			// Decrypt fields
			employee.setJuminNumber(k_sign.CryptoService.decrypt(employee.getJuminNumber(),
					k_sign.CryptoService.P10, K_SIGN_JUMIN));
			employee.setLastName(k_sign.CryptoService.decrypt(employee.getLastName(),
					k_sign.CryptoService.P20, K_SIGN_NAME));
			employee.setDayOfBirth(k_sign.CryptoService.decrypt(employee.getDayOfBirth(),
					k_sign.CryptoService.P30, K_SIGN_DOB));
		}
		return employees;
	}
	public int getLength()
	{
		return employeeMapper.getLength();
	}

	public List<Employee>  query(String condition) {
		List<Employee> employees = employeeMapper.query(condition);
		for (Employee employee : employees) {
			// Decrypt fields
			employee.setJuminNumber(k_sign.CryptoService.decrypt(employee.getJuminNumber(),
					k_sign.CryptoService.P10, K_SIGN_JUMIN));
			employee.setLastName(k_sign.CryptoService.decrypt(employee.getLastName(),
					k_sign.CryptoService.P20, K_SIGN_NAME));
			employee.setDayOfBirth(k_sign.CryptoService.decrypt(employee.getDayOfBirth(),
					k_sign.CryptoService.P30, K_SIGN_DOB));
		}
		return employees;
	}

	public List<Map<String, Object>> getDatas() {
		// TODO Auto-generated method stub
		List<Map<String, Object>> data = employeeMapper.getDatas();
		for (Map<String, Object> map : data) {
			map.put("juminNumber", k_sign.CryptoService.decrypt(map.get("juminNumber").toString(),
					k_sign.CryptoService.P10, K_SIGN_JUMIN));
			// Assuming name and birth date may also be present in the map
			if (map.containsKey("lastName")) {
				map.put("lastName", k_sign.CryptoService.decrypt(map.get("lastName").toString(),
						k_sign.CryptoService.P20, K_SIGN_NAME));
			}
			if (map.containsKey("dayOfBirth")) {
				map.put("dayOfBirth", k_sign.CryptoService.decrypt(map.get("dayOfBirth").toString(),
						k_sign.CryptoService.P30, K_SIGN_DOB));
			}
		}
		return data;
	}
	public List<Map<String, Object>> getPer() {
		// TODO Auto-generated method stub
		List<Map<String, Object>> per = employeeMapper.getPer();
		for (Map<String, Object> map : per) {
			map.put("juminNumber", k_sign.CryptoService.decrypt(map.get("juminNumber").toString(),
					k_sign.CryptoService.P10, K_SIGN_JUMIN));
			// Assuming name and birth date may also be present in the map
			if (map.containsKey("lastName")) {
				map.put("lastName", k_sign.CryptoService.decrypt(map.get("lastName").toString(),
						k_sign.CryptoService.P20, K_SIGN_NAME));
			}
			if (map.containsKey("dayOfBirth")) {
				map.put("dayOfBirth", k_sign.CryptoService.decrypt(map.get("dayOfBirth").toString(),
						k_sign.CryptoService.P30, K_SIGN_DOB));
			}
		}
		return per;
	}

	public User login(User user) {
		User u = employeeMapper.login(user.getUserName(),user.getPassword());
		return u;
	}
	public User getUserInfo(User user) {
		User u = employeeMapper.getUserInfo(user.getUserName(),user.getPassword());
		return u;
	}
}

=== File: EmployeeMapper.java ===
package com.mybatis.dao;

import java.util.List;
import java.util.Map;

import com.mybatis.beans.User;
import org.apache.ibatis.annotations.MapKey;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

import com.mybatis.beans.Employee;
import com.mybatis.beans.MapParam;

/**����ӿڱ��
 * �൱��xxxMapper.xml��ʵ��
 * @author lenovo
 *
 */
@Repository
public interface EmployeeMapper {

	/**
	 * @param id
	 * @return
	 */
	public Employee getEmpById(Integer id);
	public void addEmp(Employee employee);
	public boolean updateEmp(Employee employee);
	public void deleteEmpById(Integer id);
//	public Employee queryForOne(@Param("id")Integer id,@Param("lastName")String lastName);
//	public Map<String, Object> getByIdReturnMap(Integer id);
//	@MapKey("id")
//	public Map<Integer, Employee> getEmployeeLikeReturnMap(String lastName);
//	public List<Employee> queryForList(@Param("lastName")String lastName);
	public List<Employee> getEmps();
	public List<Employee> getEmpsByPage(Integer pageIndex, Integer size);
	public int getLength();
	public List<Employee> query(String condition);
/*	MapParam params = new MapParam("deptName","count",MapParam.ValueClass.INTEGER.getCode());
	Map<String,Integer> getDatass(MapParam params);*/
	public List<Map<String, Object>> getDatas();
	public List<Map<String, Object>> getPer();

    public User login(@Param("username") String username, @Param("password")String password);

	public User getUserInfo(@Param("username") String username, @Param("password")String password);
}


=== File: Employee.java ===
package com.mybatis.beans;

import java.io.Serializable;

public class Employee implements Serializable{

	/**
	 *
	 */
	private static final long serialVersionUID = 1L;
	private Integer id;
	private String lastName;
	private int sex;
	private String email;
	private String dayOfBirth;
	private String juminNumber;
	private Department dept;


	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}

	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getLastName() {
		return lastName;
	}
	public void setLastName(String lastName) {
		this.lastName = lastName;
	}


	public int getSex() {
		return sex;
	}
	public void setSex(int sex) {
		this.sex = sex;
	}

	public String getDayOfBirth() {
		return dayOfBirth;
	}

	public void setDayOfBirth(String dayOfBirth) {
		this.dayOfBirth = dayOfBirth;
	}

	public String getJuminNumber() {
		return juminNumber;
	}

	public void setJuminNumber(String juminNumber) {
		this.juminNumber = juminNumber;
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", lastName=" + lastName + ", sex=" + sex + ", email=" + email + ", dayOfBirth=" + dayOfBirth + ", juminNumber=" + juminNumber + ", dept=" + dept
				+ "]";
	}
	public Employee(Integer id, String lastName, int sex, String email, String dayOfBirth, String juminNumber, Department dept) {
		super();
		this.id = id;
		this.lastName = lastName;
		this.sex = sex;
		this.email = email;
		this.dayOfBirth = dayOfBirth;
		this.juminNumber = juminNumber;
		this.dept = dept;
	}
	public Department getDept() {
		return dept;
	}
	public void setDept(Department dept) {
		this.dept = dept;
	}
	public Employee(Integer id, String lastName, int sex, String email, String dayOfBirth, String juminNumber) {
		super();
		this.id = id;
		this.lastName = lastName;
		this.sex = sex;
		this.email = email;
		this.dayOfBirth = dayOfBirth;
		this.juminNumber = juminNumber;
	}
	public Employee() {
		super();
	}

}


## Current Layer: 

## File Count: 4

## Call Stacks Information
The following call stacks show the method call relationships from the upper layer to lower layer methods. Methods of the upper and middle layer in each call stack should be candiate codes for applying encyption/decryption codes. You also have to use this information to understand the data flow direction when making modifications.
[
  [
    "EmployeeController.dowm",
    "EmployeeService.getEmps",
    "EmployeeMapper.getEmps"
  ],
  [
    "EmployeeController.init",
    "EmployeeService.getEmps",
    "EmployeeMapper.getEmps"
  ],
  [
    "EmployeeController.getEmps",
    "EmployeeService.getEmps",
    "EmployeeMapper.getEmps"
  ],
  [
    "EmpController.init",
    "EmployeeService.getEmps",
    "EmployeeMapper.getEmps"
  ],
  [
    "EmpController.getEmps",
    "EmployeeService.getEmps",
    "EmployeeMapper.getEmps"
  ],
  [
    "EmployeeController.query",
    "EmployeeService.query",
    "EmployeeMapper.query"
  ],
  [
    "EmpController.query",
    "EmployeeService.query",
    "EmployeeMapper.query"
  ],
  [
    "EmployeeController.getByPage",
    "EmployeeService.getEmpsByPage",
    "EmployeeMapper.getEmpsByPage"
  ],
  [
    "EmpController.getByPage",
    "EmployeeService.getEmpsByPage",
    "EmployeeMapper.getEmpsByPage"
  ],
  [
    "EmployeeController.addEmp",
    "EmployeeService.save",
    "EmployeeMapper.addEmp"
  ],
  [
    "EmpController.addEmpByPost",
    "EmployeeService.save",
    "EmployeeMapper.addEmp"
  ],
  [
    "EmpController.addEmpByGet",
    "EmployeeService.save",
    "EmployeeMapper.addEmp"
  ],
  [
    "EmployeeController.edit",
    "EmployeeService.update",
    "EmployeeMapper.updateEmp"
  ],
  [
    "EmployeeController.editEmp",
    "EmployeeService.update",
    "EmployeeMapper.updateEmp"
  ],
  [
    "EmpController.editEmpByPost",
    "EmployeeService.update",
    "EmployeeMapper.updateEmp"
  ],
  [
    "EmpController.editEmpByGet",
    "EmployeeService.update",
    "EmployeeMapper.updateEmp"
  ]
]

## Warnings
1. Do not change the logic of existing code.
2. Only add encryption and decryption code.
3. The file_path must use the absolute path provided in source_files.
4. Do NOT perform any linting or formatting changes such as removing comments, trimming whitespace, or reformatting code. Only modify what is strictly necessary for encryption/decryption.
5. Do not remove or insert carrige return at the end of each source file. It should be as it is.
