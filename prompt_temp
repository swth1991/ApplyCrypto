<<<<<<< HEAD
# 코드 수정 실행 (Execution Phase)

## 역할

당신은 Java 코드를 **정확하게** 수정하는 전문가입니다.
아래 **수정 지침을 문자 그대로** 따라 코드를 수정하세요.

---

## 절대 준수 사항 (Critical Rules)

1. **기존 코드 유지**: 포맷, 주석, 들여쓰기, 빈 줄을 절대 변경하지 마세요
2. **지침만 수행**: 수정 지침에 명시된 부분만 수정하세요
3. **전체 코드 출력**: 수정 후 파일의 전체 소스 코드를 출력하세요
4. **코드 생략 금지**: `// ... 기존 코드 ...` 같은 생략 표현을 사용하지 마세요
5. **수정 불필요 시**: action이 "SKIP"인 파일은 수정하지 않고 이유만 출력

---

## 수정 지침 (Planning 단계에서 생성됨)

{
  "data_flow_analysis": {
    "overview": "tb_employee 테이블은 사람식별정보(성명, 주민등록번호, 생년월일, 성별)를 보관하고 있으며, 해당 컬럼은 KSign 프레임워크를 이용해 암호화/복호화한다. HTTP 요청/응답 단계에서는 순수 데이터만 전달하고, 실제 암호화·복호화 작업은 Service 레이어에서 DAO 호출 전후에 수행한다.",
    "flows": [
      {
        "flow_id": "FLOW_001",
        "flow_name": "직원 등록 (INSERT)",
        "direction": "INBOUND_TO_DB",
        "data_source": {
          "type": "HTTP_REQUEST",
          "description": "클라이언트가 GET/POST 형태의 폼 혹은 JSON 으로 직원 정보를 전송"
        },
        "data_sink": {
          "type": "DB",
          "description": "tb_employee 테이블에 INSERT"
        },
        "path": "EmployeeController.addEmp* → EmployeeService.save → EmployeeMapper.addEmp → DB",
        "sensitive_columns": [
          "last_name",
          "jumin_number",
          "day_of_birth",
          "sex"
        ],
        "crypto_action": "ENCRYPT",
        "crypto_timing": "Service 레이어에서 DAO 호출 직전"
      },
      {
        "flow_id": "FLOW_002",
        "flow_name": "직원 수정 (UPDATE)",
        "direction": "INBOUND_TO_DB",
        "data_source": {
          "type": "HTTP_REQUEST",
          "description": "클라이언트가 GET/POST 형태로 수정할 직원 정보를 전송"
        },
        "data_sink": {
          "type": "DB",
          "description": "tb_employee 테이블에 UPDATE"
        },
        "path": "EmployeeController.editEmp* → EmployeeService.update → EmployeeMapper.updateEmp → DB",
        "sensitive_columns": [
          "last_name",
          "jumin_number",
          "day_of_birth",
          "sex"
        ],
        "crypto_action": "ENCRYPT",
        "crypto_timing": "Service 레이어에서 DAO 호출 직전"
      },
      {
        "flow_id": "FLOW_003",
        "flow_name": "직원 조회 (SELECT)",
        "direction": "DB_TO_OUTBOUND",
        "data_source": {
          "type": "DB",
          "description": "tb_employee 를 SELECT (다양한 조건, 페이징, 전체 리스트) "
        },
        "data_sink": {
          "type": "HTTP_RESPONSE",
          "description": "클라이언트에게 JSON 혹은 화면(view) 로 반환"
        },
        "path": "EmployeeController.* → EmployeeService.get* → EmployeeMapper.select* → DB → Service 복호화 → Controller 반환",
        "sensitive_columns": [
          "last_name",
          "jumin_number",
          "day_of_birth",
          "sex"
        ],
        "crypto_action": "DECRYPT",
        "crypto_timing": "Service 레이어에서 DAO 반환 직후"
      }
    ],
    "layer_responsibilities": {
      "controller": "HTTP 요청/응답을 담당하고, 파라미터/결과를 Service 로 전달만 함. 암호화·복호화 로직이 들어가면 안 됨.",
      "service": "비즈니스 로직 중심. KSign 암호화·복호화 호출을 삽입하는 유일한 위치이며, DAO 호출 전후에 각각 ENCRYPT/DECRYPT 를 수행.",
      "dao (Mapper)": "MyBatis 매퍼만 담당. 전달받은 객체를 그대로 DB에 넣거나 DB 결과를 그대로 반환함. 암호화·복호화 로직이 없어야 함."
    }
  },
  "modification_instructions": [
    {
      "file_path": "/home/jihunkeom/projects/SLI_applycrypto/book-ssm/src/main/java/com/mybatis/service/EmployeeService.java",
      "file_name": "EmployeeService.java",
      "target_method": "save",
      "action": "SKIP",
      "reason": "이미 INSERT 전 KSign 암호화를 수행하고 있음(코드 내 SingleData 설정 및 encryptMultiData 호출).",
      "target_columns": [
        {
          "column_name": "last_name",
          "constant": "KsignConstants.NAME"
        },
        {
          "column_name": "jumin_number",
          "constant": "KsignConstants.JUMIN"
        },
        {
          "column_name": "day_of_birth",
          "constant": "KsignConstants.DOB"
        },
        {
          "column_name": "sex",
          "constant": "KsignConstants.GENDER"
        }
      ],
      "insertion_point": "",
      "data_object_name": "",
      "code_pattern_hint": ""
    },
    {
      "file_path": "/home/jihunkeom/projects/SLI_applycrypto/book-ssm/src/main/java/com/mybatis/service/EmployeeService.java",
      "file_name": "EmployeeService.java",
      "target_method": "update",
      "action": "SKIP",
      "reason": "UPDATE 전 암호화 로직이 존재하고, 컬럼 매핑도 정확히 지정돼 있음.",
      "target_columns": [
        {
          "column_name": "last_name",
          "constant": "KsignConstants.NAME"
        },
        {
          "column_name": "jumin_number",
          "constant": "KsignConstants.JUMIN"
        },
        {
          "column_name": "day_of_birth",
          "constant": "KsignConstants.DOB"
        },
        {
          "column_name": "sex",
          "constant": "KsignConstants.GENDER"
        }
      ],
      "insertion_point": "",
      "data_object_name": "",
      "code_pattern_hint": ""
    },
    {
      "file_path": "/home/jihunkeom/projects/SLI_applycrypto/book-ssm/src/main/java/com/mybatis/service/EmployeeService.java",
      "file_name": "EmployeeService.java",
      "target_method": "getEmps|query|getEmpsByPage|getEmpById|getDatas|getPer",
      "action": "SKIP",
      "reason": "SELECT 후 복호화 로직이 이미 구현돼 있음. 모든 반환 객체에 대해 동일한 SingleData 매핑을 사용하고 있음.",
      "target_columns": [
        {
          "column_name": "last_name",
          "constant": "KsignConstants.NAME"
        },
        {
          "column_name": "jumin_number",
          "constant": "KsignConstants.JUMIN"
        },
        {
          "column_name": "day_of_birth",
          "constant": "KsignConstants.DOB"
        },
        {
          "column_name": "sex",
          "constant": "KsignConstants.GENDER"
        }
      ],
      "insertion_point": "",
      "data_object_name": "",
      "code_pattern_hint": ""
    },
    {
      "file_path": "/home/jihunkeom/projects/SLI_applycrypto/book-ssm/src/main/java/com/mybatis/controller/EmployeeController.java",
      "file_name": "EmployeeController.java",
      "target_method": "any",
      "action": "SKIP",
      "reason": "Controller는 데이터 전달만 담당한다. 암호화·복호화는 Service 레이어에서 이미 처리하고 있어 추가 변경이 불필요함.",
      "target_columns": [],
      "insertion_point": "",
      "data_object_name": "",
      "code_pattern_hint": ""
=======
# Java Source Code Privacy Data Encryption Modification Task

## Role and Objective
You are an expert Java developer specializing in Spring Framework applications. Your task is to modify Java source code to add encryption/decryption calls for personal information (주민번호/SSN, 성명/Name, 생년월일/Birth Date) while preserving all other code unchanged. Output the unified diff of the modified source code. Do NOT output the full source code.

## Critical Requirements

### 1. Personal Information Column Recognition
Identify database columns and Java variables/properties/methods that handle personal information.
There are three types of informatioin that you have to recognize and handle.

**JUMIN Number (Social Security Number) type:**
- Column names patterns: JUMIN, SSN, JMN, RESID_NO, RRN, SOCIAL_SEC_NUM, JUM_NUM, etc.
- Variable names patterns: jumin, ssn, jmn, residNo, socialSecurityNumber, etc.

**Name type:**
- Column names pattern: NM, NAME, ACNM, CUST_NM, GVNM, INSRD_NM, USER_NAME, PERSON_NM, etc.
- Variable names patterns: name, nm, acnm, custNm, customerName, insuredName, etc.

**Birth Date type:**
- Column names patterns: BOD, DAY_OF_BIRTH, BIRTH_DATE, BIRTH_DAY, DOB, BRTH_DT, etc.
- Variable names patterns: bod, birthDate, dateOfBirth, birthDay, dob, etc.

**IMPORTANT:** Use semantic understanding to recognize variations. The column/variable name will contain hints about its purpose even if not exact matches.

### 2. Encryption/Decryption Logic Insertion Rules
** Encryption/Decryption methods:**
You have to use following methods to apply encryption or decryption.
- Encryption: k_sign.CryptoService.encrypt(input_value, policyNum, kSignValue)
- Decryption: k_sign.CryptoService.decrypt(input_value, policyNum, kSignValue)

You have to set policyNumber value depending on each type of the information :
- For JUMIN Number (Social Security Number) type : P10 (If other value is being used in existing code, that value should be changed to P10)
- For Name type : P20
- For Birth Date type : P30

You have to set kSignValue value depending on each type of the information :
- For JUMIN Number (Social Security Number) type : K_SIGN_JUMIN (If other value such like K_SIGN_SSN is being used in existing code, that value should be changed to K_SIGN_JUMIN)
- For Name type : K_SIGN_NAME
- For Birth Date type : K_SIGN_DOB

### 3. Modification Strategy
#### Types of modification
You have to modify source codes depending on each thpe of the information :

** For JUMIN Number (Social Security Number) type :**
- If you find existing encryption/description codes for this type, you just need to check and change policyNumber and kSignValue parameters as described in the above.
- You must not insert new encryption/description codes in this case.
-- Example 1: `dto.setJumin(k_sign.CryptoService.encrypt(ssn, P03, K_SIGN_SSN))` → `dto.setJumin(k_sign.CryptoService.encrypt(ssn, P10, K_SIGN_JUMIN))
-- Example 2: `ssn = k_sign.CryptoService.decrypt(dto.getJumin(), P03, K_SIGN_SSN))` → `ssn = k_sign.CryptoService.decrypt(dto.getJumin(), P10, K_SIGN_JUMIN))`

** For Name type :**
- For WRITE operations (DB INSERT/UPDATE), you have to apply encryption method BEFORE the value is assigned to DTO/Entity or passed to repository.
-- That could be done mainly with calling setters of DTO/DAO instances in the service layer. You have to decide the best way to do it by investigating existing codes.
-- Example: `dto.setName(name)` → `dto.setName(k_sign.CryptoService.encrypt(name, P20, K_SIGN_NAME))`

- For READ operations (DB SELECT): yoy have to apply decryption method AFTER the value is retrieved from DTO/Entity
-- That could be done mainly with calling getters of DTO/DAO instances in the service layer. You have to decide the best way to do it by investigating existing codes.
- Example: `String name = dto.getName()` → `String name = k_sign.CryptoService.decrypt(dto.getName(), P20, K_SIGN_NAME)`

** For Birth Date type :**
- For WRITE operations (DB INSERT/UPDATE), you have to apply encryption method BEFORE the value is assigned to DTO/Entity or passed to repository.
-- That could be done mainly with calling setters of DTO/DAO instances in the service layer. You have to decide the best way to do it by investigating existing codes.
-- Example: `dto.setDob(date)` → `dto.setDob(k_sign.CryptoService.encrypt(date, P30, K_SIGN_DOB))`

#### Modification Steps
Source code modifications must be approached through the following step-by-step process of thinking, execution, and verification:

1. Identify candidate codes.
First, you must identify candiate codes for change. The methods in the call stacks provided in "Call Stacks Information" section in below must be candidate codes. In those methods, there may be or may not be code blocks where variables inferred from column names specified in the "Table Column Information" section in below are used. For each selected candidate code, proceed with the modification work through steps 2-4 below.

2. Determin data flow type of the candidate codes.
Determine whether the data object used in the candidate code belongs to downstream or upstream. The process for making this determination is described in the sub-steps below.

2-1. The application is a backend application written in Java, and the framework can vary, including Spring, Anyframe, etc. The source code for each framework is divided into upper layer, middle layer, and lower layer. For example, as follows:

2-2. In the case of Spring framework, controller source files belong to the upper layer, service/service implementation belongs to the middle layer, and mapper or external interface source files belong to the lower layer. Among the lower layers, mapper is related to the database while external interface is not related to the database.

2-3. In the case of Anyframe framework, service/service implementation source files belong to the upper layer, business source files belong to the middle layer, and dem/dqm or external interface source files belong to the lower layer. Among the lower layers, dem/dqm is related to the database while external interface is not related to the database.

2-3. Downstream data flow means that data processing occurs as it is passed from top to bottom in the form of upper layer → middle layer → lower layer. In this case, the upper layer becomes the source layer and the lower layer becomes the destination layer. For example, if the data flow is downstream in Spring framework, the source layer is the controller and the destination layer is the mapper or external interface layer. Conversely, if it's upstream, the source layer is the mapper or external interface and the destination is the controller layer. The same approach applies to other frameworks. In Anyframe, if the data flow is downstream, the source layer is service/service implementation and the destination layer is dem/dqm or external interface. Conversely, if it's upstream, the source layer is dem/dqm or external interface layer and the destination layer is service/service implementation.

2-4. To determine whether the data flow processed in the candidate code belongs to downstream or upstream, you must identify the call relationships of the method containing the candidate code and verify the direction in which the data object is being passed. Perform this verification by comprehensively understanding the provided source code. Note that the method call relationships and data flow directions can differ.

Once the data flow of the candidate code is confirmed, perform the modification work according to the following steps:

3-1. If the data flow of the candidate code is downstream, determine whether the destination layer is a database-related layer. If it corresponds to this, proceed with modifications for encryption. If the destination layer is a layer unrelated to the database, no modifications should be made.

3-2. If the data flow of the candidate code is upstream, determine whether the source layer is a database-related layer. If it corresponds to this, proceed with modifications for decryption. If the source layer is a layer unrelated to the database, no modifications should be made.

3-3. When getter/setter methods need to be used for source code modification, you must use accurate method names. In order to do this, you have to examine provided DTO/DAO/VO class files.

4. Determine layers to change.
Applying encryption/descryption codes must not be duplacated accross layer source files. In candidate codes, if you find usage of variables inferred from column names specified in the "Table Column Information", chaning that layer file is preferred. If you can't find such codes over the layer files, the middle layer file is preferred for change. You can use each call stack provided in the "Call Stacks Information"

For example, in the case of Spring framework, the selection and modification of candidate code should be applied in either the controller layer or the service/service implementation layer, and should not occur redundantly in both layers. Similarly, in the case of Anyframe, it should be applied in either the service/service implementation layer or the business layer, and should not be applied redundantly in both layers.


**DO NOT modify:**
- Code unrelated to the specified tables and columns
- Controller layer (unless absolutely necessary)
- Repository layer (unless absolutely necessary)
- Import statements, class declarations, or method signatures
- Comments, logging statements, or validation logic


### 5. Output Requirements

If there is change that you applied in the input source file, you have to generate a Unified Diff representing the changes.
Do not output the full source file, only the diff.

### 6. Output Format Requirements
**Output Format**
For EACH input source file, you MUST output in the following format using delimiters:

```
======FILE======
{filename only, e.g., EmployeeService.java}
======REASON======
{Brief explanation of the modification or why modification is not required}
======MODIFIED_CODE======
{If modified: the Unified Diff of the changes}
{If not modified: leave this section empty}
======END======
```

The 'modification' should keep the same number of input source files in its list.
If there are modifications, ensure that "modified_code" contains the unified diff.
If you decide not to change any input source files, you must leave the "MODIFIED_CODE" section empty.

**Unified Diff Format Example:**
```diff
--- a/src/main/java/com/example/UserService.java
+++ b/src/main/java/com/example/UserService.java
@@ -32,7 +32,7 @@
     public void saveUser(UserDTO user) {
-        userMapper.insertUser(user);
+        user.setName(k_sign.CryptoService.encrypt(user.getName(), k_sign.CryptoService.P20, K_SIGN_NAME));
+        userMapper.insertUser(user);
     }
```

**Critical import point**
You must generate "modification" key. This can not be omitted.
Do not generate any other comments, contents, words except for "modifications".

## Few-shot Examples

### Example 1: Service Layer - Save (Encrypt plain data columns)
**Before:**
```java
public void saveUser(User user) {
    userDao.insert(user);
}
```
**After (Unified Diff):**
```diff
@@ -1,3 +1,5 @@
 public void saveUser(User user) {
+    user.setName(k_sign.CryptoService.encrypt(user.getName(), k_sign.CryptoService.P20, K_SIGN_NAME));
+    user.setDob(k_sign.CryptoService.encrypt(user.getDob(), k_sign.CryptoService.P30, K_SIGN_DOB));
     userDao.insert(user);
 }
```
**Explanation:** Encrypt transformation for plain data columns before saving.

### Example 2: Service Layer - Retrieve (Decrypt plain data columns)
**Before:**
```java
public User getUserById(Long id) {
    User user = userDao.findById(id);
    return user;
}
```
**After (Unified Diff):**
```diff
@@ -2,4 +2,6 @@
     User user = userDao.findById(id);
-    return user;
+    if (user != null) {
+        user.setName(k_sign.CryptoService.decrypt(user.getName(), k_sign.CryptoService.P20, K_SIGN_NAME));
+        user.setDob(k_sign.CryptoService.decrypt(user.getDob(), k_sign.CryptoService.P30, K_SIGN_DOB));
+    }
+    return user;
```
**Explanation:** Decrypt encrypted plain data columns before returning after retrieval.

### Example 3: Service Layer - Save (Encrypt resident number column, change K_SIGN_SSN to K_SIGN_JUMIN)
**Before:**
```java
public void saveUser(User user) {
    user.setJumin(k_sign.CryptoService.encrypt(user.getJumin(), k_sign.CryptoService.P03, K_SIGN_SSN));
    userDao.insert(user);
}
```
**After (Unified Diff):**
```diff
@@ -2,1 +2,1 @@
-    user.setJumin(k_sign.CryptoService.encrypt(user.getJumin(), k_sign.CryptoService.P03, K_SIGN_SSN));
+    user.setJumin(k_sign.CryptoService.encrypt(user.getJumin(), k_sign.CryptoService.P10, K_SIGN_JUMIN));
```
**Explanation:** Change k_sign.CryptoService.P03 to k_sign.CryptoService.P10 and K_SIGN_SSN to K_SIGN_JUMIN.

### Example 4: Service Layer - Retrieve (Decrypt resident number column, change K_SIGN_SSN to K_SIGN_JUMIN)
**Before:**
```java
public User getUserById(Long id) {
    User user = userDao.findById(id);
    if (user != null) {
        user.setJumin(k_sign.CryptoService.decrypt(user.getJumin(), k_sign.CryptoService.P03, K_SIGN_SSN));
    }
    return user;
}
```
**After (Unified Diff):**
```diff
@@ -4,1 +4,1 @@
-        user.setJumin(k_sign.CryptoService.decrypt(user.getJumin(), k_sign.CryptoService.P03, K_SIGN_SSN));
+        user.setJumin(k_sign.CryptoService.decrypt(user.getJumin(), k_sign.CryptoService.P10, K_SIGN_JUMIN));
```
**Explanation:** Change k_sign.CryptoService.P03 to k_sign.CryptoService.P10 and K_SIGN_SSN to K_SIGN_JUMIN.

From here, there are actual information and source codes that you have to handle
## Table Column Information
{
  "table_name": "tb_employee",
  "columns": [
    {
      "name": "day_of_birth",
      "new_column": false
    },
    {
      "name": "jumin_number",
      "new_column": false
    },
    {
      "name": "last_name",
      "new_column": false
    },
    {
      "name": "sex",
      "new_column": false
>>>>>>> upstream/main
    }
  ]
}

<<<<<<< HEAD
---

## 원본 소스 파일 (2개)

=======
## Source Files to Modify
>>>>>>> upstream/main
=== File: EmployeeController.java ===
package com.mybatis.controller;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.text.DateFormat;
import java.util.*;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.mybatis.utils.Jackson;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.mybatis.beans.Department;
import com.mybatis.beans.Employee;
import com.mybatis.service.DepartmentService;
import com.mybatis.service.EmployeeService;
import com.mybatis.service.ExcleImpl;
/*import com.servlet.JSONObject;*/

@Controller
public class EmployeeController {

	@Autowired
	private EmployeeService employeeService;

	@Autowired
	private DepartmentService deptService;

	@RequestMapping("/emps")
	public String getEmps(Map<String,Object> map)
	{
		List<Employee> emps = employeeService.getEmps();
		map.put("employees", emps);
		return "list";
	}

	@RequestMapping(value="/emps/init")
	@ResponseBody
	public Map<String, Object> init() {
		List<Employee> emp_list = employeeService.getEmps();
		List<Department> dept_list = deptService.getDepartments();
		System.out.println(emp_list.size());
		System.out.println(dept_list.size());
		Map<String,Object> map = new HashMap<>();
		map.put("count", emp_list.size());
		map.put("depts", dept_list);
		return map;
	}

	@ResponseBody
	@RequestMapping("/emps/getLength")
	public int getLength() {
		int length = employeeService.getLength();
		return length;
	}
	@ResponseBody
	@RequestMapping("/emps/search")
	public List<Employee> query(@RequestParam("condition") String condition) {
		List<Employee> length = employeeService.query("%"+condition+"%");
		return length;
	}
	@ResponseBody
	@RequestMapping(value="/emps/getByPage",method=RequestMethod.GET)
	public Collection<Employee> getByPage(@RequestParam("pageIndex") Integer pageIndex,@RequestParam("size") Integer size) {
		List<Employee> emps = employeeService.getEmpsByPage((pageIndex-1)*size,size);
		return emps;
	}


	/**ajaxʵ��ɾ��
	 * @param id
	 * @return
	 */
	@RequestMapping(value="/emp/delete",method=RequestMethod.GET)
	@ResponseBody
	public int delEmp(@RequestParam("eid") Integer id) {
		System.out.println(id);
		employeeService.delete(id);
		return id;
	}
	/**ajaxʵ��ɾ��
	 * @param id
	 * @return
	 */
	@RequestMapping(value="/emp/delEmpByBatch",method=RequestMethod.GET)
	@ResponseBody
	public String delEmpByBatch(HttpServletRequest request) {
		String json_str = request.getParameter("para");
		Map<String, Object> map = Jackson.JsonToMap(json_str);
		String ids = (String) map.get("ids");
		String[] id_array = ids.split(",");
		Map<String,Object> resturn_map = new HashMap<>();
		String result="";
		boolean status = true;
		int code=200;
		try
		{
		for(int i = 0;i < id_array.length;i++)
		{
			System.out.println("删除："+id_array[i]);
			employeeService.delete(Integer.parseInt(id_array[i]));
		}
		}
		catch (Exception e)
		{
			code = 500;
			status = false;
		}
		resturn_map.put("data","ok");
		resturn_map.put("code",code);
		resturn_map.put("status",status);
		result = ReturnMap(resturn_map);
		return result;
	}
	@RequestMapping(value="/emp/query",method=RequestMethod.GET)
	@ResponseBody
	public String query(HttpServletRequest request) {
		String json_str = request.getParameter("para");
		Map<String, Object> map = Jackson.JsonToMap(json_str);
		String condition = (String) map.get("condition");
		Map<String,Object> resturn_map = new HashMap<>();
		String result="";
		boolean status = true;
		int code=200;
		List<Employee> list = null;
		try {
			request.setCharacterEncoding("UTF-8");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		try
		{
			 list = employeeService.query("%"+condition+"%");
		}
		catch (Exception e)
		{
			code = 500;
			status = false;
		}
		resturn_map.put("data",list);
		resturn_map.put("code",code);
		resturn_map.put("status",status);
		result = ReturnMap(resturn_map);
		return result;
	}

	private String ReturnMap(Map<String, Object> map)
	{
		return (String) Jackson.MapToJson(map);
	}


	/**ajax GET��ʽʵ�����
	 * @param id
	 * @return
	 */
	@RequestMapping(value="/emp/addEmpByGet",method=RequestMethod.GET)
	@ResponseBody
		public int addEmp(@RequestParam("employeename") String employeename, @RequestParam("sex") int sex, @RequestParam("dayOfBirth") String dayOfBirth, @RequestParam("juminNumber") String juminNumber, @RequestParam("email") String email, @RequestParam("did") Integer did) {

		Employee employee = new Employee();
		employee.setEmail(email);
		employee.setLastName(employeename);
		employee.setSex(sex);
		employee.setDayOfBirth(dayOfBirth);
		employee.setJuminNumber(juminNumber);
		employee.setDept(deptService.getDeptById(did));
		System.out.println(employee);
		employeeService.save(employee);;
		return 1;
	}

	/**ajax POST��ʽʵ�����
	 * @param id
	 * @return
	 */
	@RequestMapping(value="/emp/addEmpByPost",method=RequestMethod.POST)
	@ResponseBody
		public int addEmp(@RequestBody Employee emoloyee) {
		System.out.println(emoloyee);
		employeeService.save(emoloyee);
		return 1;
	}

	/**ajaxʵ���޸ģ�һ��
	 * @param id
	 * @return
	 * @RequestParam:��������GET����ʽ�����Ĳ���
	 * GET���󣺿���ʹ��request��@RequestParam���ܲ���
	 */
	@RequestMapping(value="/emp/editEmpByGet",method=RequestMethod.GET)
	@ResponseBody
//	public int addEmp(@RequestBody String employeename,String sex,String email,Integer did) {
		public int editEmp(HttpServletRequest request/*,@RequestParam("lastName") String lastName, @RequestParam("sex") String sex, @RequestParam("email") String email, @RequestParam("eid") Integer id*/) {
		String lastName = request.getParameter("lastName");
		String email = request.getParameter("email");
		System.out.println("get:"+lastName);
		Integer id = Integer.parseInt(request.getParameter("id"));
		Integer did = Integer.parseInt(request.getParameter("did"));
		Integer sex = Integer.parseInt(request.getParameter("sex"));
		Employee employee = new Employee();
		employee.setEmail(email);
		employee.setLastName(lastName);
		employee.setSex(sex);
		employee.setDayOfBirth(request.getParameter("dayOfBirth"));
		employee.setJuminNumber(request.getParameter("juminNumber"));
		employee.setId(id);
		Department dept = new Department();
		dept.setId(did);
		employee.setDept(dept);
		employeeService.update(employee);
		return 1;
	}

	/**ajaxʵ���޸ģ�����
	 * @param id
	 * @return
	 * @RequestBody:����ֱ�ӽ�����ӳ��Ϊjavabean���󣬵��������Ĳ�������Ϊjson�ַ���(���Դ���������)��ֻ����һ��@RequestBody
	 * POST������Ҫ��@RequestBody���ܲ���
	 *
	 */
	@RequestMapping(value="/emp/editEmpByPost",method=RequestMethod.POST)
	@ResponseBody
		public int edit(HttpServletRequest request,@RequestBody Employee emp) {
		System.out.println(emp);
		employeeService.update(emp);
		return 1;
	}

	@RequestMapping(value="/getDatas")
	@ResponseBody
		public Map<String, Object> getDatas() {
		List<Map<String, Object>> json_data1 = employeeService.getDatas();
		List<Map<String, Object>> json_data2 = employeeService.getPer();

		System.out.println(json_data1);
		System.out.println(json_data2);
		Map<String,Object> map = new HashMap<>();
		map.put("count", json_data1);
		map.put("per", json_data2);
		return map;
	}
	@RequestMapping(value="/getPer")
	@ResponseBody
		public List<Map<String, Object>> getPer() {
		List<Map<String, Object>> json_data = employeeService.getPer();
		System.out.println(json_data);
		return json_data;
	}
	@RequestMapping(value="/data")
		public String getData() {
		return "data";
	}
	@RequestMapping(value="/chart")
	public String getChart() {
	return "chart";
}

@RequestMapping(value="/download_excel")
public @ResponseBody String dowm(HttpServletResponse response){
    ExcleImpl  excleImpl=new ExcleImpl();
     response.setContentType("application/binary;charset=UTF-8");
              try{
                  ServletOutputStream out=response.getOutputStream();
                  try {
                      //�����ļ�ͷ�����һ�����������������ļ���(�������ǽУ�����.pdf)
                	   DateFormat format = new java.text.SimpleDateFormat("yyyyMMddhhmmss");
                       String date = format.format(new Date());
                      response.setHeader("Content-Disposition", "attachment;fileName=" + URLEncoder.encode(date+".xls", "UTF-8"));
                  } catch (UnsupportedEncodingException e1) {
                      e1.printStackTrace();
                  }

                  String[] titles = { "�û�id", "�û�����","�û��Ա�", "�û�����" };
                  List<Employee> list = employeeService.getEmps();
                  excleImpl.export(list,titles, out);
                  return "success";
              } catch(Exception e){
                  e.printStackTrace();
                  return "������Ϣʧ��";
              }
          }


}


=== File: EmployeeService.java ===
package com.mybatis.service;

import java.util.List;
<<<<<<< HEAD
import java.util.Map;
=======
            employee.setJuminNumber(k_sign.CryptoService.decrypt(employee.getJuminNumber(),
                    k_sign.CryptoService.P10, k_sign.CryptoService.K_SIGN_JUMIN));
            employee.setLastName(k_sign.CryptoService.decrypt(employee.getLastName(),
                    k_sign.CryptoService.P20, k_sign.CryptoService.K_SIGN_NAME));
            employee.setDayOfBirth(k_sign.CryptoService.decrypt(employee.getDayOfBirth(),
                    k_sign.CryptoService.P30, k_sign.CryptoService.K_SIGN_DOB));
>>>>>>> upstream/main

import com.mybatis.beans.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

<<<<<<< HEAD
import com.mybatis.beans.Department;
=======
        employee.setJuminNumber(k_sign.CryptoService.encrypt(employee.getJuminNumber(),
                k_sign.CryptoService.P10, k_sign.CryptoService.K_SIGN_JUMIN));
        employee.setLastName(k_sign.CryptoService.encrypt(employee.getLastName(),
                k_sign.CryptoService.P20, k_sign.CryptoService.K_SIGN_NAME));
        employee.setDayOfBirth(k_sign.CryptoService.encrypt(employee.getDayOfBirth(),
                k_sign.CryptoService.P30, k_sign.CryptoService.K_SIGN_DOB));
>>>>>>> upstream/main
import com.mybatis.beans.Employee;
import com.mybatis.dao.DepartmentMapper;
import com.mybatis.dao.EmployeeMapper;

<<<<<<< HEAD
import k_sign.SingleData;
import k_sign.KsignConstants;
import k_sign.CryptoService;

@Service
=======
import k_sign.CryptoService;

        employee.setJuminNumber(k_sign.CryptoService.encrypt(employee.getJuminNumber(),
                k_sign.CryptoService.P10, k_sign.CryptoService.K_SIGN_JUMIN));
        employee.setLastName(k_sign.CryptoService.encrypt(employee.getLastName(),
                k_sign.CryptoService.P20, k_sign.CryptoService.K_SIGN_NAME));
        employee.setDayOfBirth(k_sign.CryptoService.encrypt(employee.getDayOfBirth(),
                k_sign.CryptoService.P30, k_sign.CryptoService.K_SIGN_DOB));
>>>>>>> upstream/main
public class EmployeeService {

	@Autowired
	private EmployeeMapper employeeMapper;

<<<<<<< HEAD
	@Autowired
	private DepartmentMapper deptMapper;

	@Autowired
	private CryptoService ksignService;

	public List<Employee> getEmps(){
		List<Employee> employees = employeeMapper.getEmps();
		for (Employee employee : employees) {
			SingleData dec = new SingleData();
			dec.add("last_name", KsignConstants.NAME);
			dec.add("jumin_number", KsignConstants.JUMIN);
			dec.add("day_of_birth", KsignConstants.DOB);
			dec.add("sex", KsignConstants.GENDER);
			ksignService.decryptMultiData(dec, employee);
		}
=======
        employee.setJuminNumber(k_sign.CryptoService.decrypt(employee.getJuminNumber(),
                k_sign.CryptoService.P10, k_sign.CryptoService.K_SIGN_JUMIN));
        employee.setLastName(k_sign.CryptoService.decrypt(employee.getLastName(),
                k_sign.CryptoService.P20, k_sign.CryptoService.K_SIGN_NAME));
        employee.setDayOfBirth(k_sign.CryptoService.decrypt(employee.getDayOfBirth(),
                k_sign.CryptoService.P30, k_sign.CryptoService.K_SIGN_DOB));
	private DepartmentMapper deptMapper;
	public List<Employee> getEmps(){
		List<Employee> employees = employeeMapper.getEmps();
		for (Employee employee : employees) {
			employee.setJuminNumber(k_sign.CryptoService.decrypt(employee.getJuminNumber(), k_sign.CryptoService.K_SIGN_SSM));
            employee.setJuminNumber(k_sign.CryptoService.decrypt(employee.getJuminNumber(),
                    k_sign.CryptoService.P10, k_sign.CryptoService.K_SIGN_JUMIN));
            employee.setLastName(k_sign.CryptoService.decrypt(employee.getLastName(),
                    k_sign.CryptoService.P20, k_sign.CryptoService.K_SIGN_NAME));
            employee.setDayOfBirth(k_sign.CryptoService.decrypt(employee.getDayOfBirth(),
                    k_sign.CryptoService.P30, k_sign.CryptoService.K_SIGN_DOB));
>>>>>>> upstream/main
		return employees;
	}

	public void delete(Integer id) {
<<<<<<< HEAD
		employeeMapper.deleteEmpById(id);
=======
		// TODO Auto-generated method stub
		employeeMapper.deleteEmpById(id);
            employee.setJuminNumber(k_sign.CryptoService.decrypt(employee.getJuminNumber(),
                    k_sign.CryptoService.P10, k_sign.CryptoService.K_SIGN_JUMIN));
            employee.setLastName(k_sign.CryptoService.decrypt(employee.getLastName(),
                    k_sign.CryptoService.P20, k_sign.CryptoService.K_SIGN_NAME));
            employee.setDayOfBirth(k_sign.CryptoService.decrypt(employee.getDayOfBirth(),
                    k_sign.CryptoService.P30, k_sign.CryptoService.K_SIGN_DOB));
>>>>>>> upstream/main
	}

	public void update(Employee employee)
	{
<<<<<<< HEAD
		SingleData enc = new SingleData();
		enc.add("last_name", KsignConstants.NAME);
		enc.add("jumin_number", KsignConstants.JUMIN);
		enc.add("day_of_birth", KsignConstants.DOB);
		enc.add("sex", KsignConstants.GENDER);
		ksignService.encryptMultiData(enc, employee);

		employeeMapper.updateEmp(employee);
	}

	public void save(Employee employee) {
		Department dept = deptMapper.getDeptById(employee.getDept().getId());
		employee.setDept(dept);

		SingleData enc = new SingleData();
		enc.add("last_name", KsignConstants.NAME);
		enc.add("jumin_number", KsignConstants.JUMIN);
		enc.add("day_of_birth", KsignConstants.DOB);
		enc.add("sex", KsignConstants.GENDER);
		ksignService.encryptMultiData(enc, employee);

		employeeMapper.addEmp(employee);
=======
		employee.setJuminNumber(k_sign.CryptoService.encrypt(employee.getJuminNumber(), k_sign.CryptoService.K_SIGN_SSM));
		employeeMapper.updateEmp(employee);
	}
	public void save(Employee employee) {
		// TODO Auto-generated method stub
		Department dept = deptMapper.getDeptById(employee.getDept().getId());
		employee.setDept(dept);
		employee.setJuminNumber(k_sign.CryptoService.encrypt(employee.getJuminNumber(), k_sign.CryptoService.K_SIGN_SSM));
		employeeMapper.addEmp(employee);

>>>>>>> upstream/main
	}

	public Employee getEmpById(Integer id) {
		Employee employee = employeeMapper.getEmpById(id);
<<<<<<< HEAD
		SingleData dec = new SingleData();
		dec.add("last_name", KsignConstants.NAME);
		dec.add("jumin_number", KsignConstants.JUMIN);
		dec.add("day_of_birth", KsignConstants.DOB);
		dec.add("sex", KsignConstants.GENDER);
		ksignService.decryptMultiData(dec, employee);
=======
		employee.setJuminNumber(k_sign.CryptoService.decrypt(employee.getJuminNumber(), k_sign.CryptoService.K_SIGN_SSM));
>>>>>>> upstream/main
		return employee;
	}

	public List<Employee> getEmpsByPage(Integer pageIndex,Integer size) {
		List<Employee> employees = employeeMapper.getEmpsByPage(pageIndex,size);
		for (Employee employee : employees) {
<<<<<<< HEAD
			SingleData dec = new SingleData();
			dec.add("last_name", KsignConstants.NAME);
			dec.add("jumin_number", KsignConstants.JUMIN);
			dec.add("day_of_birth", KsignConstants.DOB);
			dec.add("sex", KsignConstants.GENDER);
			ksignService.decryptMultiData(dec, employee);
		}
		return employees;
	}

=======
			employee.setJuminNumber(k_sign.CryptoService.decrypt(employee.getJuminNumber(), k_sign.CryptoService.K_SIGN_SSM));
		}
		return employees;
	}
>>>>>>> upstream/main
	public int getLength()
	{
		return employeeMapper.getLength();
	}

	public List<Employee>  query(String condition) {
		List<Employee> employees = employeeMapper.query(condition);
		for (Employee employee : employees) {
<<<<<<< HEAD
			SingleData dec = new SingleData();
			dec.add("last_name", KsignConstants.NAME);
			dec.add("jumin_number", KsignConstants.JUMIN);
			dec.add("day_of_birth", KsignConstants.DOB);
			dec.add("sex", KsignConstants.GENDER);
			ksignService.decryptMultiData(dec, employee);
=======
			employee.setJuminNumber(k_sign.CryptoService.decrypt(employee.getJuminNumber(), k_sign.CryptoService.K_SIGN_SSM));
>>>>>>> upstream/main
		}
		return employees;
	}

	public List<Map<String, Object>> getDatas() {
<<<<<<< HEAD
		List<Map<String, Object>> data = employeeMapper.getDatas();
		for (Map<String, Object> map : data) {
			SingleData dec = new SingleData();
			dec.add("last_name", KsignConstants.NAME);
			dec.add("jumin_number", KsignConstants.JUMIN);
			dec.add("day_of_birth", KsignConstants.DOB);
			dec.add("sex", KsignConstants.GENDER);
			ksignService.decryptMultiData(dec, map);
		}
		return data;
	}

	public List<Map<String, Object>> getPer() {
		List<Map<String, Object>> per = employeeMapper.getPer();
		for (Map<String, Object> map : per) {
			SingleData dec = new SingleData();
			dec.add("last_name", KsignConstants.NAME);
			dec.add("jumin_number", KsignConstants.JUMIN);
			dec.add("day_of_birth", KsignConstants.DOB);
			dec.add("sex", KsignConstants.GENDER);
			ksignService.decryptMultiData(dec, map);
=======
		// TODO Auto-generated method stub
		List<Map<String, Object>> data = employeeMapper.getDatas();
		for (Map<String, Object> map : data) {
			map.put("juminNumber", k_sign.CryptoService.decrypt(map.get("juminNumber").toString(), k_sign.CryptoService.K_SIGN_SSM));
		}
		return data;
	}
	public List<Map<String, Object>> getPer() {
		// TODO Auto-generated method stub
		List<Map<String, Object>> per = employeeMapper.getPer();
		for (Map<String, Object> map : per) {
			map.put("juminNumber", k_sign.CryptoService.decrypt(map.get("juminNumber").toString(), k_sign.CryptoService.K_SIGN_SSM));
>>>>>>> upstream/main
		}
		return per;
	}

	public User login(User user) {
		User u = employeeMapper.login(user.getUserName(),user.getPassword());
		return u;
	}
<<<<<<< HEAD

=======
>>>>>>> upstream/main
	public User getUserInfo(User user) {
		User u = employeeMapper.getUserInfo(user.getUserName(),user.getPassword());
		return u;
	}
}


<<<<<<< HEAD

---

## 출력 형식 (반드시 준수)

각 파일에 대해 **반드시 아래 형식**으로 출력하세요:

```
======FILE======
파일명.java
======REASON======
수정 이유 또는 건너뛴 이유
======MODIFIED_CODE======
수정된 전체 소스 코드 (action이 SKIP인 경우 빈 문자열)
======END======
```

### 예시 (수정이 필요한 경우)

```
======FILE======
EmployeeService.java
======REASON======
employee 테이블 INSERT 전 name, phone 칼럼 암호화 코드 추가
======MODIFIED_CODE======
package com.example.service;

import com.ksign.KsignConstants;
import com.ksign.SingleData;

public class EmployeeService {

    @Autowired
    private KsignService ksignService;

    @Autowired
    private EmployeeDao employeeDao;

    public void saveEmployee(MultiData list) {
        // 암호화 처리
        SingleData ksignEnc = new SingleData();
        ksignEnc.add("name", KsignConstants.NAME);
        ksignEnc.add("phone", KsignConstants.TEL_NO);
        ksignService.encryptMultiData(ksignEnc, list);

        employeeDao.insert(list);
    }
}
======END======
```

### 예시 (수정이 불필요한 경우)

```
======FILE======
EmployeeController.java
======REASON======
SKIP - 이 컨트롤러는 암호화 대상 칼럼을 직접 다루지 않음
======MODIFIED_CODE======

======END======
```

---

## 현재 레이어: 

---

## 지금 코드 수정을 시작하세요

위 수정 지침에 따라 각 파일의 코드를 수정하고, 지정된 출력 형식으로 결과를 출력하세요.
**모든 대상 파일에 대해 출력해야 합니다** (수정 여부와 관계없이).
=======
=== File: Employee.java ===
package com.mybatis.beans;

import java.io.Serializable;

public class Employee implements Serializable{

	/**
	 *
	 */
	private static final long serialVersionUID = 1L;
	private Integer id;
	private String lastName;
	private int sex;
	private String email;
	private String dayOfBirth;
	private String juminNumber;
	private Department dept;


	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}

	public Integer getId() {
		return id;
	}
	public void setId(Integer id) {
		this.id = id;
	}
	public String getLastName() {
		return lastName;
	}
	public void setLastName(String lastName) {
		this.lastName = lastName;
	}


	public int getSex() {
		return sex;
	}
	public void setSex(int sex) {
		this.sex = sex;
	}

	public String getDayOfBirth() {
		return dayOfBirth;
	}

	public void setDayOfBirth(String dayOfBirth) {
		this.dayOfBirth = dayOfBirth;
	}

	public String getJuminNumber() {
		return juminNumber;
	}

	public void setJuminNumber(String juminNumber) {
		this.juminNumber = juminNumber;
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", lastName=" + lastName + ", sex=" + sex + ", email=" + email + ", dayOfBirth=" + dayOfBirth + ", juminNumber=" + juminNumber + ", dept=" + dept
				+ "]";
	}
	public Employee(Integer id, String lastName, int sex, String email, String dayOfBirth, String juminNumber, Department dept) {
		super();
		this.id = id;
		this.lastName = lastName;
		this.sex = sex;
		this.email = email;
		this.dayOfBirth = dayOfBirth;
		this.juminNumber = juminNumber;
		this.dept = dept;
	}
	public Department getDept() {
		return dept;
	}
	public void setDept(Department dept) {
		this.dept = dept;
	}
	public Employee(Integer id, String lastName, int sex, String email, String dayOfBirth, String juminNumber) {
		super();
		this.id = id;
		this.lastName = lastName;
		this.sex = sex;
		this.email = email;
		this.dayOfBirth = dayOfBirth;
		this.juminNumber = juminNumber;
	}
	public Employee() {
		super();
	}

}


=== File: EmployeeMapper.java ===
package com.mybatis.dao;

import java.util.List;
import java.util.Map;

import com.mybatis.beans.User;
import org.apache.ibatis.annotations.MapKey;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;

import com.mybatis.beans.Employee;
import com.mybatis.beans.MapParam;

/**����ӿڱ��
 * �൱��xxxMapper.xml��ʵ��
 * @author lenovo
 *
 */
@Repository
public interface EmployeeMapper {

	/**
	 * @param id
	 * @return
	 */
	public Employee getEmpById(Integer id);
	public void addEmp(Employee employee);
	public boolean updateEmp(Employee employee);
	public void deleteEmpById(Integer id);
//	public Employee queryForOne(@Param("id")Integer id,@Param("lastName")String lastName);
//	public Map<String, Object> getByIdReturnMap(Integer id);
//	@MapKey("id")
//	public Map<Integer, Employee> getEmployeeLikeReturnMap(String lastName);
//	public List<Employee> queryForList(@Param("lastName")String lastName);
	public List<Employee> getEmps();
	public List<Employee> getEmpsByPage(Integer pageIndex, Integer size);
	public int getLength();
	public List<Employee> query(String condition);
/*	MapParam params = new MapParam("deptName","count",MapParam.ValueClass.INTEGER.getCode());
	Map<String,Integer> getDatass(MapParam params);*/
	public List<Map<String, Object>> getDatas();
	public List<Map<String, Object>> getPer();

    public User login(@Param("username") String username, @Param("password")String password);

	public User getUserInfo(@Param("username") String username, @Param("password")String password);
}


## Current Layer: 

## File Count: 4

## Call Stacks Information
The following call stacks show the method call relationships from the upper layer to lower layer methods. Methods of the upper and middle layer in each call stack should be candiate codes for applying encyption/decryption codes. You also have to use this information to understand the data flow direction when making modifications.
[
  [
    "EmployeeController.dowm",
    "EmployeeService.getEmps",
    "EmployeeMapper.getEmps"
  ],
  [
    "EmployeeController.init",
    "EmployeeService.getEmps",
    "EmployeeMapper.getEmps"
  ],
  [
    "EmployeeController.getEmps",
    "EmployeeService.getEmps",
    "EmployeeMapper.getEmps"
  ],
  [
    "EmpController.init",
    "EmployeeService.getEmps",
    "EmployeeMapper.getEmps"
  ],
  [
    "EmpController.getEmps",
    "EmployeeService.getEmps",
    "EmployeeMapper.getEmps"
  ],
  [
    "EmployeeController.query",
    "EmployeeService.query",
    "EmployeeMapper.query"
  ],
  [
    "EmpController.query",
    "EmployeeService.query",
    "EmployeeMapper.query"
  ],
  [
    "EmployeeController.getByPage",
    "EmployeeService.getEmpsByPage",
    "EmployeeMapper.getEmpsByPage"
  ],
  [
    "EmpController.getByPage",
    "EmployeeService.getEmpsByPage",
    "EmployeeMapper.getEmpsByPage"
  ],
  [
    "EmployeeController.addEmp",
    "EmployeeService.save",
    "EmployeeMapper.addEmp"
  ],
  [
    "EmpController.addEmpByPost",
    "EmployeeService.save",
    "EmployeeMapper.addEmp"
  ],
  [
    "EmpController.addEmpByGet",
    "EmployeeService.save",
    "EmployeeMapper.addEmp"
  ],
  [
    "EmployeeController.edit",
    "EmployeeService.update",
    "EmployeeMapper.updateEmp"
  ],
  [
    "EmployeeController.editEmp",
    "EmployeeService.update",
    "EmployeeMapper.updateEmp"
  ],
  [
    "EmpController.editEmpByPost",
    "EmployeeService.update",
    "EmployeeMapper.updateEmp"
  ],
  [
    "EmpController.editEmpByGet",
    "EmployeeService.update",
    "EmployeeMapper.updateEmp"
  ]
]

## Warnings
1. Do not change the logic of existing code.
2. Only add encryption and decryption code.
3. The file_path must use the absolute path provided in source_files.
4. Do NOT perform any linting or formatting changes such as removing comments, trimming whitespace, or reformatting code. Only modify what is strictly necessary for encryption/decryption.
5. Do not remove or insert carrige return at the end of each source file. It should be as it is.
>>>>>>> upstream/main
