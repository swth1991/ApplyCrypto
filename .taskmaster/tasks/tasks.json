{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "설정 관리 시스템 구현 (Configuration Manager)",
        "description": "JSON 설정 파일을 로드하고 검증하는 Configuration Manager 모듈을 구현합니다. 프로젝트 경로, 파일 타입, SQL Wrapping 타입, 암호화 대상 테이블/칼럼 정보를 파싱하고 스키마 검증을 수행합니다.",
        "details": "Configuration Manager 클래스를 구현하여 다음 기능을 제공합니다:\n1. JSON 설정 파일 로드: json.load()를 사용하여 설정 파일 파싱\n2. 스키마 검증: jsonschema 라이브러리를 사용하여 필수 필드(project_path, source_file_types, sql_wrapping_type, access_tables) 검증\n3. 설정값 접근: 프로퍼티 메서드를 통해 각 설정값에 대한 타입 안전한 접근 제공\n4. 오류 처리: 파일 없음, 잘못된 JSON, 스키마 위반 등에 대한 명확한 에러 메시지 출력\n5. 기본값 설정: 선택적 필드에 대한 기본값 제공\n\n구현 시 고려사항:\n- 단일 책임 원칙(SRP): 설정 로드와 검증만 담당\n- 의존성 주입: 설정 파일 경로를 생성자 파라미터로 받음\n- 타입 힌트: 모든 메서드에 입출력 타입 명시\n- 한글 주석: 각 메서드와 복잡한 로직에 주석 추가",
        "testStrategy": "단위 테스트(pytest)를 작성하여 다음을 검증합니다:\n1. 유효한 설정 파일 로드 성공 테스트\n2. 필수 필드 누락 시 예외 발생 테스트\n3. 잘못된 JSON 형식 처리 테스트\n4. 각 설정값의 정확한 파싱 테스트\n5. 기본값 적용 테스트\n6. 파일 없음 예외 처리 테스트\n\n테스트 데이터: 유효한 설정 파일, 필드 누락 설정, 잘못된 타입 설정 등 다양한 시나리오 포함",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "JSON 파일 로드 및 파싱 기능 구현",
            "description": "Configuration Manager의 JSON 파일 로드 및 파싱 기능을 구현합니다.",
            "dependencies": [],
            "details": "json.load()를 사용하여 설정 파일을 파싱하고, FileNotFoundError와 JSONDecodeError 예외를 처리합니다. 생성자에서 설정 파일 경로를 받아 파일을 로드하고, 파싱된 데이터를 내부 변수에 저장합니다. 타입 힌트를 명시하고 한글 주석을 추가합니다.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 유효한 JSON 파일 로드 성공, 파일 없음 예외 처리, 잘못된 JSON 형식 처리를 검증합니다."
          },
          {
            "id": 2,
            "title": "jsonschema를 사용한 스키마 검증 로직 구현",
            "description": "Configuration Manager의 스키마 검증 기능을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "jsonschema 라이브러리를 사용하여 필수 필드(project_path, source_file_types, sql_wrapping_type, access_tables)를 검증합니다. JSON Schema를 정의하고 validate() 메서드를 호출하여 검증을 수행합니다. 스키마 위반 시 명확한 에러 메시지를 출력합니다. 타입 힌트와 한글 주석을 추가합니다.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 필수 필드 누락 시 예외 발생, 잘못된 타입 처리, 유효한 설정 파일 검증 성공을 확인합니다."
          },
          {
            "id": 3,
            "title": "프로퍼티 메서드를 통한 타입 안전한 설정값 접근 인터페이스 구현",
            "description": "Configuration Manager의 설정값 접근 인터페이스를 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "프로퍼티 메서드(@property)를 사용하여 project_path, source_file_types, sql_wrapping_type, access_tables 등 각 설정값에 대한 타입 안전한 접근을 제공합니다. 각 프로퍼티는 적절한 타입 힌트를 명시하고, 필요시 타입 변환을 수행합니다. 한글 주석으로 각 프로퍼티의 역할을 설명합니다.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 각 설정값의 정확한 파싱, 타입 안전성, 프로퍼티 메서드의 올바른 반환값을 검증합니다."
          },
          {
            "id": 4,
            "title": "에러 처리 및 기본값 설정 로직 구현",
            "description": "Configuration Manager의 에러 처리 및 기본값 설정 기능을 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "파일 없음, 잘못된 JSON, 스키마 위반 등 다양한 에러 상황에 대한 명확한 에러 메시지를 출력합니다. 선택적 필드에 대한 기본값을 설정하고, 사용자 정의 예외 클래스(ConfigurationError)를 정의합니다. 모든 에러 처리 로직에 타입 힌트와 한글 주석을 추가합니다.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 파일 없음 예외 처리, 기본값 적용, 다양한 에러 시나리오 처리를 검증합니다."
          }
        ]
      },
      {
        "id": 2,
        "title": "소스 파일 수집 및 인덱싱 (Source File Collector)",
        "description": "Java Spring Boot 프로젝트의 모든 소스 파일(.java, .xml 등)을 재귀적으로 탐색하고 메타데이터와 함께 수집하는 Source File Collector 모듈을 구현합니다.",
        "details": "Source File Collector 클래스를 구현하여 다음 기능을 제공합니다:\n1. 재귀적 파일 탐색: pathlib.Path를 사용하여 프로젝트 디렉터리 재귀 탐색\n2. 파일 필터링: 설정에서 지정한 확장자(.java, .xml)만 수집\n3. 메타데이터 추출: 파일 경로, 파일명, 확장자, 크기, 수정 시간 등 저장\n4. 중복 제거: 동일 파일 중복 수집 방지\n5. 크로스 플랫폼 호환성: Windows, Linux, macOS 경로 호환성 보장\n6. 성능 최적화: 대규모 프로젝트 처리 시 메모리 효율성 고려\n\n구현 시 고려사항:\n- pathlib 사용으로 OS 독립적 경로 처리\n- 제너레이터 패턴으로 메모리 효율성 확보\n- 숨김 파일 및 빌드 디렉터리(.git, target, build) 제외\n- SourceFile 데이터 모델 정의 및 사용\n- 타입 힌트: List[SourceFile] 반환",
        "testStrategy": "단위 테스트(pytest)를 작성하여 다음을 검증합니다:\n1. 지정된 확장자 파일만 수집되는지 확인\n2. 재귀적 탐색이 모든 하위 디렉터리를 포함하는지 확인\n3. 중복 파일이 제외되는지 확인\n4. 메타데이터가 정확히 추출되는지 확인\n5. 빌드 디렉터리 제외 확인\n6. 대규모 파일 시뮬레이션 테스트(성능)\n\n테스트 데이터: 다양한 디렉터리 구조와 파일 타입을 포함한 테스트 프로젝트 생성",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "pathlib.Path를 사용한 재귀적 디렉터리 탐색 기능 구현",
            "description": "pathlib.Path를 활용하여 프로젝트 디렉터리를 재귀적으로 탐색하는 기능을 구현합니다. 숨김 파일 및 빌드 디렉터리(.git, target, build 등)를 제외하고 모든 하위 디렉터리를 순회합니다.",
            "dependencies": [],
            "details": "pathlib.Path.rglob() 또는 Path.iterdir()를 사용하여 재귀적 탐색 구현. 제외 대상 디렉터리 목록을 설정에서 관리하고, 경로 필터링 로직 작성. OS 독립적 경로 처리를 위해 pathlib 활용. 제너레이터 패턴으로 메모리 효율성 확보.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 테스트 디렉터리 구조 생성 후 모든 하위 디렉터리가 탐색되는지 확인. 숨김 파일과 빌드 디렉터리가 정확히 제외되는지 검증."
          },
          {
            "id": 2,
            "title": "설정 기반 파일 필터링 로직 구현",
            "description": "Configuration Manager에서 제공하는 source_file_types 설정을 기반으로 지정된 확장자(.java, .xml 등)의 파일만 필터링하는 로직을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "Configuration Manager의 source_file_types 설정값을 읽어 확장자 목록 생성. 파일 확장자를 확인하여 필터링 수행. 대소문자 구분 없이 처리(.JAVA, .java 모두 포함). 필터링 로직을 별도 메서드로 분리하여 재사용성 확보. 정규표현식 또는 문자열 비교로 구현.",
            "status": "done",
            "testStrategy": "다양한 확장자 파일(.java, .xml, .txt, .class 등)을 포함한 테스트 디렉터리 생성. 지정된 확장자만 수집되고 나머지는 제외되는지 검증. 대소문자 혼합 확장자 처리 확인."
          },
          {
            "id": 3,
            "title": "파일 메타데이터 추출 기능 구현",
            "description": "수집된 파일의 메타데이터(파일 경로, 파일명, 확장자, 크기, 수정 시간)를 추출하고 SourceFile 데이터 모델에 저장하는 기능을 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "SourceFile 데이터 모델 정의(dataclass 또는 namedtuple 사용). pathlib.Path의 stat() 메서드로 파일 크기와 수정 시간 추출. 절대 경로와 상대 경로 모두 저장. 파일명과 확장자 분리 추출. 타입 힌트 적용하여 List[SourceFile] 반환. 메타데이터 추출 로직을 별도 메서드로 분리.",
            "status": "done",
            "testStrategy": "다양한 파일 크기와 수정 시간을 가진 테스트 파일 생성. 추출된 메타데이터가 정확한지 검증. 파일명, 확장자, 크기, 수정 시간이 올바르게 저장되는지 확인. 경로 형식이 OS 독립적으로 처리되는지 검증."
          },
          {
            "id": 4,
            "title": "중복 제거 및 크로스 플랫폼 경로 호환성 처리 구현",
            "description": "동일 파일의 중복 수집을 방지하고, Windows, Linux, macOS 간 경로 호환성을 보장하는 기능을 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "파일의 절대 경로 또는 inode(Linux/macOS) 기반 중복 검사. Set 자료구조를 사용하여 중복 제거. pathlib.Path.resolve()로 정규화된 절대 경로 생성. 경로 구분자 통일(항상 forward slash 사용). 심볼릭 링크 처리 고려. 중복 검사 로직을 별도 메서드로 분리.",
            "status": "done",
            "testStrategy": "동일 파일을 여러 경로로 참조하는 테스트 케이스 생성. 중복이 정확히 제거되는지 검증. Windows와 Unix 스타일 경로 모두에서 정상 작동 확인. 심볼릭 링크 처리 검증."
          },
          {
            "id": 5,
            "title": "제너레이터 패턴을 활용한 메모리 효율적 구현 및 성능 최적화",
            "description": "제너레이터 패턴을 적용하여 대규모 프로젝트 처리 시 메모리 효율성을 확보하고, 성능 최적화를 수행하는 기능을 구현합니다.",
            "dependencies": [
              4
            ],
            "details": "파일 탐색 및 필터링 로직을 제너레이터로 구현하여 lazy evaluation 수행. 전체 파일 목록을 메모리에 로드하지 않고 필요시에만 처리. 배치 처리 옵션 제공(예: 1000개 단위로 처리). 진행 상황 표시 기능 추가(tqdm 라이브러리 사용). 성능 측정 로직 추가(처리 시간, 메모리 사용량). 캐싱 메커니즘 고려.",
            "status": "done",
            "testStrategy": "대규모 파일 시뮬레이션(10,000개 이상 파일) 테스트 수행. 메모리 사용량이 파일 수에 선형적으로 증가하지 않는지 검증. 처리 시간 측정 및 성능 기준 설정. 제너레이터가 올바르게 작동하는지 확인. 배치 처리 옵션 동작 검증."
          }
        ]
      },
      {
        "id": 3,
        "title": "CLI 기본 구조 및 명령어 파서 구현",
        "description": "argparse를 사용하여 CLI 기본 구조를 구축하고, analyze, list, modify 명령어와 각 옵션(--all, --db, --modified, --endpoint, --callgraph)을 파싱하는 CLI Controller를 구현합니다.",
        "details": "CLI Controller 클래스를 구현하여 다음 기능을 제공합니다:\n1. 명령어 정의: analyze, list, modify 명령어 구현\n2. 옵션 파싱: argparse를 사용하여 각 명령의 옵션 정의\n   - analyze: --config (설정 파일 경로)\n   - list: --all, --db, --modified, --endpoint, --callgraph (옵션)\n   - modify: --config, --dry-run (미리보기 모드)\n3. 도움말 메시지: 각 명령과 옵션에 대한 명확한 설명 제공\n4. 에러 처리: 잘못된 명령어 및 옵션에 대한 에러 메시지\n5. 진행 상황 표시: 장시간 작업 시 진행률 표시\n6. 로깅: 모든 작업을 로그 파일에 기록\n\n구현 시 고려사항:\n- 명령어별 서브파서 사용\n- 각 명령은 해당 비즈니스 로직 모듈 호출\n- 결과 포맷팅: 테이블, JSON, 트리 구조 등 다양한 형식 지원\n- 타입 힌트: 명령 실행 결과 타입 명시",
        "testStrategy": "단위 테스트(pytest)를 작성하여 다음을 검증합니다:\n1. 각 명령어가 올바르게 파싱되는지 확인\n2. 옵션 조합이 정확히 처리되는지 확인\n3. 잘못된 명령어에 대한 에러 처리 확인\n4. 도움말 메시지 출력 확인\n5. 로깅이 정상 작동하는지 확인\n\n테스트 데이터: 다양한 명령어 조합 및 옵션 시뮬레이션",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "argparse 기본 CLI 구조 및 서브파서 설정 구현",
            "description": "argparse를 사용하여 CLI의 기본 구조를 구축하고, analyze, list, modify 명령어별 서브파서를 설정합니다.",
            "dependencies": [],
            "details": "ArgumentParser 메인 파서 생성, add_subparsers()로 서브파서 생성, 각 명령어별 서브파서 추가(analyze, list, modify), 각 서브파서에 필요한 인자 및 옵션 정의, 도움말 메시지 설정, 파서 구조 검증",
            "status": "done",
            "testStrategy": "pytest를 사용하여 파서 생성 확인, 각 서브파서 정상 작동 확인, 인자 파싱 정확성 검증"
          },
          {
            "id": 2,
            "title": "analyze, list, modify 명령어 옵션 파싱 로직 구현",
            "description": "각 명령어의 옵션을 정의하고 파싱하는 로직을 구현합니다. analyze(--config), list(--all, --db, --modified, --endpoint, --callgraph), modify(--config, --dry-run).",
            "dependencies": [
              1
            ],
            "details": "analyze 명령어에 --config 옵션 추가, list 명령어에 --all, --db, --modified, --endpoint, --callgraph 옵션 추가, modify 명령어에 --config, --dry-run 옵션 추가, 옵션별 타입 및 기본값 설정, 옵션 조합 검증 로직 구현",
            "status": "done",
            "testStrategy": "각 명령어별 옵션 파싱 테스트, 옵션 조합 정확성 검증, 기본값 적용 확인, 옵션 타입 검증"
          },
          {
            "id": 3,
            "title": "명령어별 도움말 메시지 및 에러 처리 구현",
            "description": "각 명령어와 옵션에 대한 명확한 도움말 메시지를 작성하고, 잘못된 명령어 및 옵션에 대한 에러 처리를 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "각 명령어별 상세한 도움말 메시지 작성, 각 옵션별 설명 추가, 잘못된 명령어 입력 시 에러 메시지 출력, 필수 옵션 누락 시 에러 처리, 옵션 값 유효성 검증, 사용자 친화적 에러 메시지 포맷팅",
            "status": "done",
            "testStrategy": "도움말 메시지 출력 확인, 잘못된 명령어 에러 처리 검증, 필수 옵션 누락 시 에러 확인, 옵션 값 유효성 검증 테스트"
          },
          {
            "id": 4,
            "title": "진행 상황 표시 및 로깅 기능 구현",
            "description": "장시간 작업 시 진행률을 표시하고, 모든 작업을 로그 파일에 기록하는 기능을 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "진행 상황 표시를 위한 프로그레스 바 구현(tqdm 등), 로깅 설정(logging 모듈), 로그 파일 경로 설정, 로그 레벨 설정(DEBUG, INFO, WARNING, ERROR), 각 명령어 실행 시 로그 기록, 타임스탬프 및 작업 상태 로깅",
            "status": "done",
            "testStrategy": "프로그레스 바 출력 확인, 로그 파일 생성 및 기록 검증, 로그 레벨별 필터링 확인, 타임스탬프 정확성 검증"
          },
          {
            "id": 5,
            "title": "CLI Controller와 비즈니스 로직 모듈 간 연결 인터페이스 설계",
            "description": "각 명령어와 비즈니스 로직 모듈(Configuration Manager, Source File Collector, Java AST Parser 등) 간의 연결 인터페이스를 설계하고 구현합니다.",
            "dependencies": [
              4
            ],
            "details": "CLI Controller 클래스 구조 설계, 각 명령어별 핸들러 메서드 정의, 비즈니스 로직 모듈 호출 인터페이스 설계, 결과 포맷팅(테이블, JSON, 트리 구조) 구현, 타입 힌트 추가, 명령어 실행 결과 반환 타입 명시, 모듈 간 데이터 전달 구조 정의",
            "status": "done",
            "testStrategy": "CLI Controller 클래스 생성 및 메서드 호출 테스트, 비즈니스 로직 모듈 호출 확인, 결과 포맷팅 정확성 검증, 타입 힌트 적용 확인, 모듈 간 데이터 전달 정확성 검증"
          }
        ]
      },
      {
        "id": 4,
        "title": "데이터 영속화 계층 구현 (Data Persistence Layer)",
        "description": "분석 결과(소스 파일 목록, Call Graph, DB 접근 파일 목록, 수정 내역)를 JSON 파일로 직렬화하여 저장하고 로드하는 Data Persistence Layer를 구현합니다.",
        "details": "DataPersistenceManager 클래스를 구현하여 다음 기능을 제공합니다:\n1. JSON 직렬화: 데이터 모델(SourceFile, Method, CallRelation, TableAccessInfo, ModificationRecord)을 JSON으로 변환\n2. JSON 역직렬화: JSON 파일을 읽어 데이터 모델로 복원\n3. 파일 관리: 프로젝트별 결과 디렉터리 생성 및 관리\n4. 버전 관리: 분석 결과에 타임스탬프 추가하여 버전 추적\n5. 데이터 검증: 로드된 데이터의 스키마 검증\n6. 캐싱: 이미 분석된 결과 캐싱하여 재분석 시 활용\n\n구현 시 고려사항:\n- JSON Schema 정의: 각 데이터 모델의 스키마 정의\n- 커스텀 JSON 인코더/디코더: datetime, Path 등 기본 타입 외 처리\n- 에러 처리: 파일 손상, 권한 문제 등 처리\n- 타입 힌트: 모든 메서드에 입출력 타입 명시\n- 한글 주석: 각 메서드와 복잡한 로직에 주석 추가",
        "testStrategy": "단위 테스트(pytest)를 작성하여 다음을 검증합니다:\n1. 데이터 모델이 JSON으로 정확히 직렬화되는지 확인\n2. JSON에서 데이터 모델로 정확히 역직렬화되는지 확인\n3. 파일 저장 및 로드 성공 확인\n4. 손상된 JSON 파일 처리 확인\n5. 버전 관리 기능 확인\n6. 캐싱 기능 확인\n\n테스트 데이터: 다양한 데이터 모델 인스턴스 및 손상된 JSON 파일",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "데이터 모델 정의 및 JSON 스키마 작성",
            "description": "SourceFile, Method, CallRelation, TableAccessInfo, ModificationRecord 데이터 모델을 정의하고 각 모델에 대한 JSON 스키마를 작성합니다.",
            "dependencies": [],
            "details": "Python dataclass를 사용하여 5개의 데이터 모델을 정의하고, jsonschema 라이브러리를 사용하여 각 모델의 JSON 스키마를 작성합니다. 각 모델에는 필수 필드, 선택적 필드, 타입 정보를 명시하고, 한글 주석을 추가합니다. 스키마 파일은 JSON 형식으로 저장하여 검증에 사용합니다.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 각 데이터 모델의 인스턴스 생성, 필드 검증, 스키마 유효성 확인 테스트를 작성합니다."
          },
          {
            "id": 2,
            "title": "커스텀 JSON 인코더/디코더 구현",
            "description": "datetime, Path, Enum 등 기본 JSON 타입이 아닌 객체들을 처리하는 커스텀 JSON 인코더와 디코더를 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "json.JSONEncoder를 상속하여 CustomJSONEncoder 클래스를 구현하고, datetime을 ISO 8601 형식으로, Path를 문자열로 변환합니다. 반대로 CustomJSONDecoder를 구현하여 JSON 문자열을 읽을 때 datetime과 Path 객체로 복원합니다. 각 메서드에 타입 힌트와 한글 주석을 추가합니다.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 datetime, Path, Enum 객체의 인코딩/디코딩 정확성, 라운드트립 변환 성공 여부를 검증합니다."
          },
          {
            "id": 3,
            "title": "JSON 직렬화 및 역직렬화 로직 구현",
            "description": "DataPersistenceManager 클래스의 핵심 메서드인 serialize_to_json()과 deserialize_from_json()을 구현합니다.",
            "dependencies": [
              1,
              2
            ],
            "details": "serialize_to_json() 메서드는 데이터 모델 객체를 JSON 문자열로 변환하고, deserialize_from_json() 메서드는 JSON 문자열을 데이터 모델 객체로 복원합니다. 커스텀 인코더/디코더를 활용하며, 에러 발생 시 명확한 예외 메시지를 출력합니다. 모든 메서드에 타입 힌트와 한글 주석을 추가합니다.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 다양한 데이터 모델의 직렬화/역직렬화 정확성, 데이터 손실 없음, 예외 처리를 검증합니다."
          },
          {
            "id": 4,
            "title": "프로젝트별 결과 디렉터리 생성 및 파일 관리",
            "description": "프로젝트별 결과 디렉터리를 생성하고, JSON 파일을 저장/로드하는 파일 관리 기능을 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "create_project_directory() 메서드로 프로젝트별 디렉터리 구조를 생성하고, save_to_file() 메서드로 JSON 데이터를 파일에 저장합니다. load_from_file() 메서드로 파일에서 JSON 데이터를 읽습니다. 디렉터리 생성 시 권한 문제를 처리하고, 파일 경로는 Path 객체로 관리합니다. 모든 메서드에 타입 힌트와 한글 주석을 추가합니다.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 디렉터리 생성, 파일 저장/로드, 권한 문제 처리, 경로 관리를 검증합니다."
          },
          {
            "id": 5,
            "title": "타임스탬프 기반 버전 관리 및 캐싱 기능 구현",
            "description": "분석 결과에 타임스탬프를 추가하여 버전을 추적하고, 이미 분석된 결과를 캐싱하여 재분석 시 활용하는 기능을 구현합니다.",
            "dependencies": [
              4
            ],
            "details": "add_timestamp() 메서드로 데이터 모델에 생성 시간과 수정 시간을 추가합니다. get_version_info() 메서드로 버전 정보를 조회합니다. CacheManager 클래스를 구현하여 분석 결과를 메모리 또는 디스크에 캐싱하고, get_cached_result() 메서드로 캐시된 결과를 조회합니다. 캐시 만료 시간을 설정하여 오래된 캐시를 자동으로 제거합니다.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 타임스탬프 추가, 버전 정보 조회, 캐시 저장/조회, 캐시 만료 처리를 검증합니다."
          },
          {
            "id": 6,
            "title": "에러 처리 및 데이터 검증 구현",
            "description": "손상된 JSON 파일, 파일 권한 문제, 스키마 위반 등 다양한 에러 상황을 처리하고 데이터 무결성을 검증합니다.",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "validate_data() 메서드로 로드된 데이터가 JSON 스키마를 준수하는지 검증합니다. handle_corrupted_file() 메서드로 손상된 JSON 파일을 감지하고 처리합니다. handle_permission_error() 메서드로 파일 접근 권한 문제를 처리합니다. 모든 에러 상황에 대해 명확한 예외 메시지와 로깅을 제공합니다. 데이터 복구 전략(백업 복원 등)을 구현합니다.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 손상된 JSON 파일 처리, 권한 문제 처리, 스키마 검증, 데이터 복구, 예외 메시지 정확성을 검증합니다."
          }
        ]
      },
      {
        "id": 5,
        "title": "Java AST 파서 구현 (Java AST Parser)",
        "description": "tree-sitter를 사용하여 Java 소스 코드를 추상 구문 트리(AST)로 파싱하고, 클래스, 메서드, 변수 정보를 추출하는 Java AST Parser 모듈을 구현합니다.",
        "details": "JavaASTParser 클래스를 구현하여 다음 기능을 제공합니다:\n1. 파일 파싱: tree-sitter를 사용하여 Java 파일을 AST로 변환\n2. 클래스 정보 추출: 클래스명, 부모 클래스, 인터페이스, 어노테이션 추출\n3. 메서드 정보 추출: 메서드명, 반환 타입, 파라미터(이름, 타입), 접근 제어자 추출\n4. 변수 정보 추출: 필드명, 타입, 초기값 추출\n5. 메서드 본문 분석: 메서드 내 메서드 호출 식별\n6. 에러 처리: 파싱 실패 시 대체 파서(정규표현식) 사용\n7. 캐싱: 파싱된 AST 캐싱하여 재파싱 방지\n\n구현 시 고려사항:\n- tree-sitter 우선 사용, 실패 시 정규표현식으로 fallback\n- 최신 Java 버전 지원(Java 11, 17 등)\n- 정규표현식 보조 수단으로 활용\n- Method 데이터 모델 정의 및 사용\n- 타입 힌트: List[Method], List[str] 등 명시\n- 한글 주석: 복잡한 파싱 로직에 주석 추가",
        "testStrategy": "단위 테스트(pytest)를 작성하여 다음을 검증합니다:\n1. 간단한 Java 클래스 파싱 확인\n2. 메서드 정보 정확히 추출 확인\n3. 파라미터 정보 정확히 추출 확인\n4. 메서드 호출 식별 확인\n5. 최신 Java 문법(람다, 스트림 등) 처리 확인\n6. 파싱 실패 시 fallback 동작 확인\n7. 캐싱 기능 확인\n\n테스트 데이터: 다양한 Java 코드 샘플(간단한 클래스, 복잡한 메서드, 최신 문법 포함)",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Tree-sitter를 사용한 Java 파일 파싱 및 AST 변환 기능 구현",
            "description": "Tree-sitter 라이브러리를 활용하여 Java 소스 코드를 추상 구문 트리(AST)로 변환하는 기본 파싱 기능을 구현합니다.",
            "dependencies": [],
            "details": "JavaASTParser 클래스의 parse_file() 메서드를 구현하여 tree-sitter Java 파서를 초기화하고 Java 파일을 읽어 AST로 변환합니다. 파싱 성공 여부를 확인하고 AST 루트 노드를 반환하는 기능을 포함합니다. 타입 힌트로 반환 타입을 명시하고 복잡한 파싱 로직에 한글 주석을 추가합니다.",
            "status": "done",
            "testStrategy": "Tree-sitter를 사용한 간단한 Java 클래스 파싱 성공 여부를 확인하는 단위 테스트를 작성합니다. 유효한 Java 파일과 잘못된 파일을 모두 테스트하여 예외 처리를 검증합니다."
          },
          {
            "id": 2,
            "title": "클래스 정보 추출 로직 구현 (클래스명, 부모 클래스, 인터페이스, 어노테이션)",
            "description": "AST에서 클래스 선언 노드를 탐색하여 클래스명, 부모 클래스, 구현 인터페이스, 어노테이션 정보를 추출하는 기능을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "extract_class_info() 메서드를 구현하여 AST의 class_declaration 노드를 찾고, 클래스명은 identifier에서, 부모 클래스는 superclass에서, 인터페이스는 interfaces에서 추출합니다. 어노테이션은 modifiers 내의 annotation 노드에서 추출합니다. 반환 타입을 List[ClassInfo] 또는 Dict로 명시하고 복잡한 노드 탐색 로직에 한글 주석을 추가합니다.",
            "status": "done",
            "testStrategy": "다양한 Java 클래스 샘플(상속, 인터페이스 구현, 어노테이션 포함)을 파싱하여 클래스 정보가 정확히 추출되는지 검증합니다. 제네릭 클래스와 내부 클래스도 테스트합니다."
          },
          {
            "id": 3,
            "title": "메서드 정보 추출 로직 구현 (메서드명, 반환 타입, 파라미터, 접근 제어자)",
            "description": "AST에서 메서드 선언 노드를 탐색하여 메서드명, 반환 타입, 파라미터(이름, 타입), 접근 제어자 정보를 추출하는 기능을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "extract_method_info() 메서드를 구현하여 method_declaration 노드에서 메서드명, 반환 타입, 파라미터 목록을 추출합니다. 파라미터는 formal_parameters 내의 formal_parameter 노드에서 이름과 타입을 각각 추출합니다. 접근 제어자(public, private, protected, package-private)는 modifiers에서 추출합니다. Method 데이터 모델을 정의하고 List[Method] 타입 힌트를 명시합니다.",
            "status": "done",
            "testStrategy": "다양한 메서드 시그니처(파라미터 없음, 여러 파라미터, 제네릭 타입, 가변 인자)를 포함한 Java 클래스를 파싱하여 메서드 정보가 정확히 추출되는지 검증합니다."
          },
          {
            "id": 4,
            "title": "필드 정보 추출 및 메서드 본문 분석 구현",
            "description": "AST에서 필드 선언 노드를 탐색하여 필드명, 타입, 초기값을 추출하고, 메서드 본문에서 메서드 호출을 식별하는 기능을 구현합니다.",
            "dependencies": [
              1,
              3
            ],
            "details": "extract_field_info() 메서드를 구현하여 field_declaration 노드에서 필드명, 타입, 초기값을 추출합니다. analyze_method_calls() 메서드를 구현하여 메서드 본문의 method_invocation 노드를 탐색하고 호출되는 메서드명과 대상 객체를 식별합니다. 복잡한 표현식 분석에 한글 주석을 추가하고 List[str] 타입 힌트를 명시합니다.",
            "status": "done",
            "testStrategy": "다양한 필드 선언(초기값 있음/없음, 제네릭 타입, 상수)과 메서드 호출 패턴(체인 호출, 람다 내 호출)을 포함한 Java 코드를 파싱하여 정보 추출이 정확한지 검증합니다."
          },
          {
            "id": 5,
            "title": "Tree-sitter 실패 시 정규표현식 기반 Fallback 파서 구현",
            "description": "Tree-sitter 파싱이 실패할 경우 정규표현식을 사용한 대체 파서를 구현하여 파싱 안정성을 확보합니다.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "fallback_parse() 메서드를 구현하여 tree-sitter 파싱 실패 시 정규표현식을 사용한 간단한 파서로 클래스명, 메서드명, 필드명을 추출합니다. 정규표현식 패턴: 클래스는 'class\\s+(\\w+)', 메서드는 '(public|private|protected)?\\s+\\w+\\s+(\\w+)\\s*\\(', 필드는 '(public|private|protected)?\\s+\\w+\\s+(\\w+)\\s*[=;]'를 사용합니다.",
            "status": "done",
            "testStrategy": "Tree-sitter가 파싱할 수 없는 비표준 Java 코드나 손상된 파일을 사용하여 fallback 파서가 정상 작동하는지 검증합니다."
          },
          {
            "id": 6,
            "title": "파싱된 AST 캐싱 기능 구현",
            "description": "파싱된 AST를 메모리 또는 디스크에 캐싱하여 동일 파일의 재파싱을 방지하고 성능을 최적화하는 기능을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "CacheManager 클래스를 구현하여 파일 경로와 수정 시간을 키로 사용하는 캐시 메커니즘을 제공합니다. get_cached_ast() 메서드는 캐시에서 AST를 조회하고, set_cached_ast() 메서드는 AST를 캐시에 저장합니다. 파일 수정 시간이 변경되면 캐시를 무효화합니다. 선택적으로 pickle을 사용하여 디스크 캐싱도 구현합니다. 캐시 크기 제한과 LRU 정책을 고려합니다.",
            "status": "done",
            "testStrategy": "동일 파일을 여러 번 파싱할 때 캐시가 사용되는지 확인합니다. 파일 수정 후 캐시가 무효화되는지 검증합니다. 캐시 성능 개선을 측정하는 벤치마크 테스트를 작성합니다."
          },
          {
            "id": 7,
            "title": "최신 Java 문법 지원 및 종합 에러 처리 구현",
            "description": "람다 표현식, 스트림 API, 레코드, 텍스트 블록 등 최신 Java 문법을 지원하고, 파싱 실패, 타입 불일치 등 다양한 에러를 처리하는 기능을 구현합니다.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "lambda_expression 노드를 탐색하여 람다 표현식을 식별하고, method_invocation 내 lambda_expression을 분석합니다. 스트림 API 호출(stream(), map(), filter() 등)을 특별히 처리합니다. 레코드 선언(record_declaration)과 텍스트 블록(text_block)을 지원합니다. 에러 처리: 파싱 실패 시 상세한 에러 메시지와 라인 번호를 포함하여 로깅합니다. 타입 불일치나 미지원 문법은 경고로 기록하고 계속 진행합니다.",
            "status": "done",
            "testStrategy": "람다 표현식, 스트림 API, 레코드, 텍스트 블록을 포함한 Java 11, 17 코드를 파싱하여 정상 처리되는지 검증합니다. 파싱 실패 시 에러 메시지가 명확한지 확인합니다. 다양한 에러 시나리오(문법 오류, 타입 오류, 미지원 기능)에 대한 에러 처리를 테스트합니다."
          }
        ]
      },
      {
        "id": 6,
        "title": "XML Mapper 파서 구현 (XML Mapper Parser)",
        "description": "lxml 또는 xml.etree.ElementTree를 사용하여 MyBatis Mapper XML 파일을 파싱하고, SQL 쿼리에서 테이블명과 칼럼명을 정규표현식으로 추출하는 XML Mapper Parser 모듈을 구현합니다.",
        "details": "XMLMapperParser 클래스를 구현하여 다음 기능을 제공합니다:\n1. XML 파일 파싱: lxml을 사용하여 MyBatis Mapper XML 파싱\n2. SQL 태그 추출: <select>, <insert>, <update>, <delete> 태그 내 SQL 쿼리 추출\n3. CDATA 처리: CDATA 섹션 내 SQL 정확히 처리\n4. 테이블명 추출: 정규표현식으로 FROM, INTO, UPDATE 절에서 테이블명 추출\n5. 칼럼명 추출: SELECT, INSERT, UPDATE 절에서 칼럼명 추출\n6. 파라미터 처리: MyBatis 파라미터 표기법(#{}, ${}) 인식\n7. 메서드 매핑: Mapper 인터페이스 메서드와 XML SQL 매핑\n8. 에러 처리: 잘못된 XML, 파싱 실패 등 처리\n\n구현 시 고려사항:\n- 정규표현식 최적화: 복잡한 SQL 패턴 처리\n- 대소문자 무시: SQL 키워드 대소문자 구분 안 함\n- 주석 제거: SQL 내 주석 제거 후 파싱\n- TableAccessInfo 데이터 모델 정의 및 사용\n- 타입 힌트: List[TableAccessInfo], Dict[str, List[str]] 등 명시\n- 한글 주석: 정규표현식 및 복잡한 로직에 주석 추가",
        "testStrategy": "단위 테스트(pytest)를 작성하여 다음을 검증합니다:\n1. 간단한 SELECT 쿼리에서 테이블명 추출 확인\n2. 복잡한 JOIN 쿼리에서 테이블명 추출 확인\n3. INSERT, UPDATE, DELETE 쿼리 처리 확인\n4. CDATA 섹션 처리 확인\n5. 칼럼명 정확히 추출 확인\n6. MyBatis 파라미터 표기법 인식 확인\n7. 주석 제거 확인\n8. 잘못된 XML 처리 확인\n\n테스트 데이터: 다양한 MyBatis Mapper XML 샘플(간단한 쿼리, 복잡한 JOIN, CDATA 포함)",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "lxml을 사용한 MyBatis Mapper XML 파일 파싱 기능 구현",
            "description": "lxml 라이브러리를 사용하여 MyBatis Mapper XML 파일을 파싱하고 XML 구조를 분석하는 기능을 구현합니다.",
            "dependencies": [],
            "details": "XMLMapperParser 클래스의 기본 구조를 설계하고, lxml의 etree를 사용하여 XML 파일을 로드하고 파싱합니다. 네임스페이스 처리, 루트 요소 검증, 기본 에러 처리를 포함하여 구현합니다. 파싱된 XML 트리를 내부 상태로 유지하고, 이후 SQL 태그 추출을 위한 기반을 마련합니다.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 유효한 XML 파일 파싱 성공, 잘못된 XML 형식 처리, 파일 없음 예외 처리, 네임스페이스 포함 XML 파싱 등을 검증합니다."
          },
          {
            "id": 2,
            "title": "<select>, <insert>, <update>, <delete> 태그에서 SQL 쿼리 추출 로직 구현",
            "description": "MyBatis Mapper XML의 SQL 태그에서 SQL 쿼리를 추출하고 정규화하는 기능을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "XMLMapperParser에 SQL 태그 추출 메서드를 구현합니다. XPath를 사용하여 <select>, <insert>, <update>, <delete> 태그를 찾고, 각 태그의 id, parameterType, resultType 속성을 추출합니다. 태그 내 텍스트 콘텐츠를 추출하고, 공백을 정규화합니다. 동적 SQL 요소(<if>, <choose> 등)는 일단 무시하고 정적 SQL만 처리합니다.",
            "status": "done",
            "testStrategy": "다양한 SQL 태그 유형에서 쿼리 추출 확인, 속성 정보 정확성 검증, 동적 SQL 요소 처리 확인, 빈 태그 처리 등을 테스트합니다."
          },
          {
            "id": 3,
            "title": "CDATA 섹션 처리 및 SQL 주석 제거 기능 구현",
            "description": "CDATA 섹션 내 SQL을 정확히 처리하고, SQL 주석을 제거하는 기능을 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "CDATA 섹션 내 SQL을 올바르게 추출하는 로직을 구현합니다. lxml은 CDATA를 자동으로 처리하므로, 추출된 텍스트에서 SQL 주석을 제거합니다. 한 줄 주석(--), 여러 줄 주석(/* */), 그리고 문자열 리터럴 내 주석 문자는 보존하도록 정규표현식을 작성합니다. 주석 제거 후 불필요한 공백과 줄바꿈을 정규화합니다.",
            "status": "done",
            "testStrategy": "CDATA 섹션 포함 XML 파싱, 한 줄 주석 제거 확인, 여러 줄 주석 제거 확인, 문자열 내 주석 문자 보존 확인, 공백 정규화 검증 등을 테스트합니다."
          },
          {
            "id": 4,
            "title": "정규표현식을 사용한 테이블명 및 칼럼명 추출 로직 구현",
            "description": "SQL 쿼리에서 정규표현식을 사용하여 테이블명과 칼럼명을 추출하는 기능을 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "테이블명 추출을 위해 FROM, INTO, UPDATE, JOIN 절에서 테이블명을 정규표현식으로 추출합니다. 대소문자 무시 플래그(re.IGNORECASE)를 사용하고, 테이블 별칭도 함께 추출합니다. 칼럼명 추출을 위해 SELECT, INSERT, UPDATE 절에서 칼럼명을 추출합니다. 복잡한 표현식(함수 호출, 산술 연산)은 제외하고 기본 칼럼명만 추출합니다. TableAccessInfo 데이터 모델을 정의하여 테이블명, 칼럼명, 쿼리 타입을 저장합니다.",
            "status": "done",
            "testStrategy": "간단한 SELECT 쿼리에서 테이블명 추출 확인, 복잡한 JOIN 쿼리 처리, INSERT/UPDATE/DELETE 쿼리 처리, 칼럼명 정확히 추출 확인, 별칭 처리 검증 등을 테스트합니다."
          },
          {
            "id": 5,
            "title": "MyBatis 파라미터 표기법(#{}, ${}) 인식 및 Mapper 메서드 매핑 구현",
            "description": "MyBatis 파라미터 표기법을 인식하고, Mapper 인터페이스 메서드와 XML SQL을 매핑하는 기능을 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "SQL 쿼리에서 #{paramName}과 ${paramName} 패턴을 정규표현식으로 추출합니다. 파라미터 이름과 타입 정보를 수집합니다. Mapper XML의 namespace 속성과 SQL 태그의 id 속성을 조합하여 메서드 시그니처를 생성합니다. Java AST Parser에서 추출한 Mapper 인터페이스 메서드와 매핑합니다. 매핑 결과를 딕셔너리 형태로 저장하여 메서드별 SQL 정보를 관리합니다.",
            "status": "done",
            "testStrategy": "파라미터 표기법 정확히 인식 확인, 파라미터 이름 추출 검증, namespace와 id 조합 확인, Mapper 메서드 매핑 정확성 검증, 매핑 실패 시 에러 처리 확인 등을 테스트합니다."
          },
          {
            "id": 6,
            "title": "복잡한 JOIN 쿼리, 잘못된 XML 등 다양한 시나리오에 대한 에러 처리 구현",
            "description": "복잡한 SQL 패턴과 잘못된 입력에 대한 포괄적인 에러 처리 및 복구 메커니즘을 구현합니다.",
            "dependencies": [
              4,
              5
            ],
            "details": "복잡한 JOIN 쿼리(INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN)에서 모든 테이블명을 정확히 추출하는 로직을 강화합니다. 서브쿼리 처리, 테이블 함수 처리 등을 포함합니다. 잘못된 XML 형식, 파싱 실패, 정규표현식 매칭 실패 등에 대한 예외 처리를 구현합니다. 로깅을 통해 에러 정보를 기록하고, 부분 실패 시에도 처리 가능한 데이터는 반환하도록 구현합니다. 타입 힌트와 한글 주석을 추가하여 코드 가독성을 높입니다.",
            "status": "done",
            "testStrategy": "복잡한 JOIN 쿼리 처리 확인, 서브쿼리 포함 쿼리 처리, 잘못된 XML 형식 처리, 파싱 실패 시 대체 처리, 부분 실패 복구 확인, 에러 로깅 검증, 타입 힌트 정확성 확인 등을 테스트합니다."
          }
        ]
      },
      {
        "id": 7,
        "title": "Call Graph 생성 및 메서드 추적 (Call Graph Builder)",
        "description": "Java AST 정보를 기반으로 메서드 호출 관계(caller-callee)를 추적하여 그래프 구조를 생성하고, REST API 엔드포인트부터 DAO/Mapper까지 이어지는 호출 체인을 구성하는 Call Graph Builder 모듈을 구현합니다.",
        "details": "CallGraphBuilder 클래스를 구현하여 다음 기능을 제공합니다:\n1. 메서드 호출 추적: AST 분석을 통해 메서드 호출 식별\n2. 그래프 구성: networkx를 사용하여 호출 관계 그래프 생성\n3. 엔드포인트 식별: @RequestMapping, @GetMapping 등 어노테이션으로 REST API 엔드포인트 식별\n4. 호출 체인 생성: 엔드포인트부터 시작하여 깊이 우선 탐색(DFS)으로 호출 체인 구성\n5. 레이어 분류: Controller, Service, DAO, Mapper 레이어 자동 분류\n6. 순환 참조 감지: 무한 루프 방지\n7. 캐싱: 생성된 Call Graph 캐싱\n\n구현 시 고려사항:\n- networkx 라이브러리 활용\n- CallRelation 데이터 모델 정의 및 사용\n- Spring Framework 어노테이션 인식\n- 동적 프록시, 리플렉션 등 정적 분석 한계 인식\n- 타입 힌트: nx.DiGraph, List[CallRelation] 등 명시\n- 한글 주석: 그래프 탐색 알고리즘에 주석 추가",
        "testStrategy": "단위 테스트(pytest)를 작성하여 다음을 검증합니다:\n1. 간단한 메서드 호출 관계 추적 확인\n2. 다중 레이어 호출 체인 구성 확인\n3. 엔드포인트 정확히 식별 확인\n4. 순환 참조 감지 확인\n5. 레이어 분류 정확성 확인\n6. 그래프 구조 정확성 확인\n7. 캐싱 기능 확인\n\n테스트 데이터: 다양한 메서드 호출 패턴을 포함한 테스트 Java 코드",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Java AST 분석을 통한 메서드 호출 식별 로직 구현",
            "description": "Java AST 정보를 기반으로 메서드 호출 관계를 추적하고 식별하는 핵심 로직을 구현합니다.",
            "dependencies": [
              5
            ],
            "details": "JavaASTParser에서 추출한 AST 정보를 활용하여 메서드 호출 식별 로직을 구현합니다. 메서드 본문 내의 모든 메서드 호출을 식별하고, caller와 callee 관계를 추출합니다. 정규표현식을 보조 수단으로 활용하여 복잡한 호출 패턴(체이닝, 람다 등)을 처리합니다. CallRelation 데이터 모델을 정의하여 호출 관계 정보를 구조화합니다.",
            "status": "done",
            "testStrategy": "단위 테스트를 작성하여 간단한 메서드 호출, 체이닝 호출, 람다 표현식 내 호출 등 다양한 패턴을 검증합니다."
          },
          {
            "id": 2,
            "title": "networkx를 사용한 호출 관계 그래프 생성 및 관리",
            "description": "networkx 라이브러리를 활용하여 메서드 호출 관계를 방향성 그래프(DiGraph)로 구성하고 관리합니다.",
            "dependencies": [
              1
            ],
            "details": "CallRelation 정보를 기반으로 networkx의 DiGraph를 생성합니다. 각 노드는 메서드를 나타내고, 간선은 호출 관계를 나타냅니다. 그래프에 메타데이터(메서드 시그니처, 클래스명, 레이어 정보)를 저장합니다. 그래프 조회, 수정, 분석을 위한 메서드들을 구현합니다. 타입 힌트로 nx.DiGraph를 명시합니다.",
            "status": "done",
            "testStrategy": "그래프 생성, 노드/간선 추가, 메타데이터 저장 및 조회 기능을 테스트합니다. 그래프 구조의 정확성을 검증합니다."
          },
          {
            "id": 3,
            "title": "Spring Framework 어노테이션 인식을 통한 REST API 엔드포인트 식별",
            "description": "@RequestMapping, @GetMapping, @PostMapping 등 Spring 어노테이션을 인식하여 REST API 엔드포인트를 식별합니다.",
            "dependencies": [
              5
            ],
            "details": "JavaASTParser에서 추출한 클래스 및 메서드 어노테이션 정보를 분석합니다. @RequestMapping, @GetMapping, @PostMapping, @PutMapping, @DeleteMapping 등을 인식하고, 각 엔드포인트의 경로, HTTP 메서드, 메서드 시그니처를 추출합니다. 클래스 레벨과 메서드 레벨 어노테이션을 모두 처리하여 전체 경로를 구성합니다.",
            "status": "done",
            "testStrategy": "다양한 Spring 어노테이션 조합을 포함한 테스트 코드로 엔드포인트 식별 정확성을 검증합니다."
          },
          {
            "id": 4,
            "title": "깊이 우선 탐색(DFS) 알고리즘을 사용한 호출 체인 생성",
            "description": "REST API 엔드포인트부터 시작하여 DFS 알고리즘으로 호출 체인을 구성합니다.",
            "dependencies": [
              2,
              3
            ],
            "details": "식별된 엔드포인트를 시작점으로 하여 networkx 그래프에서 DFS를 수행합니다. 각 엔드포인트부터 DAO/Mapper까지 이어지는 모든 호출 경로를 추출합니다. 호출 체인을 리스트 형태로 반환하며, 각 체인은 메서드 시그니처와 레이어 정보를 포함합니다. 한글 주석으로 DFS 알고리즘 로직을 상세히 설명합니다.",
            "status": "done",
            "testStrategy": "단순 호출 체인, 다중 경로 호출, 깊은 호출 체인 등 다양한 시나리오에서 DFS 동작을 검증합니다."
          },
          {
            "id": 5,
            "title": "Controller, Service, DAO, Mapper 레이어 자동 분류 로직 구현",
            "description": "메서드가 속한 클래스의 이름, 패키지, 어노테이션을 기반으로 레이어를 자동 분류합니다.",
            "dependencies": [
              1
            ],
            "details": "클래스명 패턴(Controller, Service, DAO, Repository, Mapper 등)과 패키지 구조를 분석하여 레이어를 분류합니다. @Controller, @Service, @Repository 등 Spring 어노테이션도 활용합니다. 분류 규칙을 설정 파일로 관리하여 확장성을 보장합니다. 분류 결과를 메서드 메타데이터에 저장합니다.",
            "status": "done",
            "testStrategy": "다양한 클래스명, 패키지 구조, 어노테이션 조합으로 레이어 분류 정확성을 검증합니다."
          },
          {
            "id": 6,
            "title": "순환 참조 감지 및 무한 루프 방지 메커니즘 구현",
            "description": "호출 체인 생성 중 순환 참조를 감지하고 무한 루프를 방지합니다.",
            "dependencies": [
              2,
              4
            ],
            "details": "DFS 탐색 중 방문한 노드를 추적하여 순환 참조를 감지합니다. 순환 참조가 발견되면 해당 경로를 표시하고 탐색을 중단합니다. 최대 깊이 제한을 설정하여 추가적인 무한 루프 방지 메커니즘을 구현합니다. 순환 참조 정보를 로깅하고 분석 결과에 포함시킵니다.",
            "status": "done",
            "testStrategy": "순환 참조 패턴(A->B->A, A->B->C->A 등)을 포함한 테스트 그래프로 감지 기능을 검증합니다."
          },
          {
            "id": 7,
            "title": "생성된 Call Graph 캐싱 및 성능 최적화",
            "description": "생성된 Call Graph를 캐싱하여 재분석 시 성능을 최적화합니다.",
            "dependencies": [
              2
            ],
            "details": "생성된 Call Graph를 pickle 또는 JSON 형식으로 캐싱합니다. 소스 파일의 수정 시간을 추적하여 캐시 유효성을 판단합니다. 캐시 무효화 전략을 구현하여 파일 변경 시 자동으로 재분석합니다. 캐시 저장소 경로를 설정 파일로 관리합니다. 메모리 효율성을 위해 대규모 그래프 처리 시 청크 단위 캐싱을 고려합니다.",
            "status": "done",
            "testStrategy": "캐시 생성, 로드, 무효화 기능을 테스트합니다. 캐시 사용 시 성능 개선을 측정합니다."
          }
        ]
      },
      {
        "id": 8,
        "title": "DB 접근 코드 자동 식별 (DB Access Analyzer)",
        "description": "설정 파일의 테이블 및 칼럼 정보와 XML/Java 파일에서 추출한 SQL 쿼리를 비교하여, 특정 테이블에 접근하는 파일을 필터링하고 태그를 부여하는 DB Access Analyzer 모듈을 구현합니다.",
        "details": "DBAccessAnalyzer 클래스를 구현하여 다음 기능을 제공합니다:\n1. 테이블 접근 파일 식별: XML Mapper Parser와 Java AST Parser 결과를 조합하여 테이블 접근 파일 식별\n2. 파일 태그 부여: 각 파일에 접근하는 테이블명을 태그로 부여\n3. 레이어별 파일 분류: Mapper XML, DTO, DAO, Service, Controller 파일 분류\n4. SQL Wrapping Type 적응: 설정의 sql_wrapping_type에 따라 탐색 전략 변경(Strategy Pattern)\n5. 칼럼 레벨 분석: 특정 칼럼에 접근하는 코드 식별\n6. 의존성 추적: 테이블 접근 파일 간 의존성 추적\n7. 결과 저장: TableAccessInfo 데이터 모델로 결과 저장\n\n구현 시 고려사항:\n- Strategy Pattern으로 sql_wrapping_type별 처리 분리\n- 정규표현식으로 SQL 쿼리 분석\n- Call Graph 활용하여 상위 레이어 파일 식별\n- 타입 힌트: List[TableAccessInfo], Dict[str, List[SourceFile]] 등 명시\n- 한글 주석: 복잡한 분석 로직에 주석 추가",
        "testStrategy": "단위 테스트(pytest)를 작성하여 다음을 검증합니다:\n1. 특정 테이블 접근 파일 정확히 식별 확인\n2. 파일 태그 정확히 부여 확인\n3. 레이어별 파일 분류 정확성 확인\n4. 칼럼 레벨 분석 정확성 확인\n5. 의존성 추적 정확성 확인\n6. sql_wrapping_type별 처리 확인\n\n테스트 데이터: 다양한 테이블 접근 패턴을 포함한 테스트 프로젝트",
        "priority": "high",
        "dependencies": [
          5,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "XML Mapper Parser와 Java AST Parser 결과 통합 분석",
            "description": "XML Mapper Parser와 Java AST Parser에서 추출한 SQL 쿼리 결과를 조합하여 테이블 접근 파일을 식별하는 통합 분석 로직을 구현합니다.",
            "dependencies": [],
            "details": "두 파서의 결과를 병합하여 중복을 제거하고, 각 파일에서 접근하는 테이블 목록을 추출합니다. 정규표현식을 사용하여 SQL 쿼리에서 테이블명을 추출하고, 설정 파일의 테이블 정보와 비교하여 매칭합니다. 타입 힌트로 Dict[str, List[str]] 형태의 파일-테이블 매핑 결과를 반환합니다.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 다양한 SQL 패턴(SELECT, INSERT, UPDATE, DELETE)에서 테이블명이 정확히 추출되는지 검증하고, 중복 제거 로직을 확인합니다."
          },
          {
            "id": 2,
            "title": "파일 태그 부여 기능 구현",
            "description": "각 소스 파일에 접근하는 테이블명을 태그로 부여하는 기능을 구현합니다. 파일 메타데이터에 테이블 태그를 추가하고 저장합니다.",
            "dependencies": [
              1
            ],
            "details": "SourceFile 데이터 모델에 tags 필드를 추가하여 테이블명 리스트를 저장합니다. 각 파일에 대해 접근하는 모든 테이블을 식별하고 태그로 부여합니다. 중복 태그를 제거하고 정렬하여 일관성을 유지합니다. 타입 힌트: List[SourceFile]을 반환합니다.",
            "status": "done",
            "testStrategy": "pytest로 특정 파일의 태그가 정확히 부여되는지 확인하고, 중복 태그 제거 및 정렬 로직을 검증합니다."
          },
          {
            "id": 3,
            "title": "레이어별 파일 분류 로직 구현",
            "description": "Mapper XML, DTO, DAO, Service, Controller 파일을 파일 경로와 명명 규칙을 기반으로 자동 분류하는 로직을 구현합니다.",
            "dependencies": [
              2
            ],
            "details": "파일 경로와 파일명 패턴을 분석하여 각 파일의 레이어를 식별합니다. 정규표현식으로 'Mapper.xml', 'DTO', 'DAO', 'Service', 'Controller' 패턴을 매칭합니다. 설정 파일에서 레이어 식별 규칙을 읽어 적용합니다. 타입 힌트: Dict[str, List[SourceFile]]을 반환합니다.",
            "status": "done",
            "testStrategy": "pytest로 다양한 파일명과 경로에서 레이어가 정확히 분류되는지 확인하고, 경계 케이스(예: 'ServiceDTO')를 검증합니다."
          },
          {
            "id": 4,
            "title": "Strategy Pattern을 사용한 sql_wrapping_type별 처리 전략 구현",
            "description": "설정의 sql_wrapping_type(예: mybatis, jpa, jdbc)에 따라 SQL 쿼리 분석 전략을 다르게 적용하는 Strategy Pattern을 구현합니다.",
            "dependencies": [
              1
            ],
            "details": "SQLParsingStrategy 인터페이스를 정의하고, MyBatisStrategy, JPAStrategy, JDBCStrategy 등 구체적인 전략 클래스를 구현합니다. 각 전략은 해당 SQL 형식에 맞게 테이블명을 추출합니다. DBAccessAnalyzer에서 설정에 따라 적절한 전략을 선택하여 사용합니다. 타입 힌트: SQLParsingStrategy 인터페이스를 명시합니다.",
            "status": "done",
            "testStrategy": "pytest로 각 sql_wrapping_type별로 SQL 쿼리가 올바르게 분석되는지 확인하고, 전략 전환이 정상 작동하는지 검증합니다."
          },
          {
            "id": 5,
            "title": "칼럼 레벨 분석 및 의존성 추적 구현",
            "description": "특정 칼럼에 접근하는 코드를 식별하고, 테이블 접근 파일 간의 의존성을 추적하는 기능을 구현합니다.",
            "dependencies": [
              3,
              4
            ],
            "details": "SQL 쿼리에서 칼럼명을 추출하여 테이블-칼럼 매핑을 생성합니다. Call Graph를 활용하여 파일 간 호출 관계를 분석하고, 테이블 접근 의존성을 추적합니다. 상위 레이어(Service, Controller)에서 하위 레이어(DAO, Mapper)로의 의존성 경로를 기록합니다. 타입 힌트: Dict[str, List[str]]로 의존성 그래프를 반환합니다.",
            "status": "done",
            "testStrategy": "pytest로 특정 칼럼 접근이 정확히 식별되는지 확인하고, 의존성 경로가 올바르게 추적되는지 검증합니다."
          },
          {
            "id": 6,
            "title": "결과 저장 및 TableAccessInfo 데이터 모델 구현",
            "description": "분석 결과를 TableAccessInfo 데이터 모델로 구조화하여 저장하고, 데이터 영속성 계층과 연동하는 기능을 구현합니다.",
            "dependencies": [
              5
            ],
            "details": "TableAccessInfo 데이터 모델을 정의하여 테이블명, 접근 파일 목록, 칼럼 정보, 의존성, 레이어 분류 등을 포함합니다. 분석 결과를 JSON 또는 데이터베이스 형식으로 저장합니다. 데이터 영속성 계층(Data Persistence Layer)과 연동하여 결과를 저장합니다. 타입 힌트: List[TableAccessInfo]를 반환합니다.",
            "status": "done",
            "testStrategy": "pytest로 TableAccessInfo 객체가 정확히 생성되고, 결과가 올바른 형식으로 저장되는지 확인합니다."
          }
        ]
      },
      {
        "id": 10,
        "title": "CLI 명령어 구현 및 통합 (CLI Commands Implementation)",
        "description": "analyze, list, modify 명령어를 완전히 구현하고, 각 명령어가 해당 비즈니스 로직 모듈을 올바르게 호출하여 결과를 포맷팅하여 출력하는 기능을 구현합니다.",
        "details": "CLI 명령어 구현:\n\n1. analyze 명령어:\n   - 설정 파일 로드 (Configuration Manager)\n   - 소스 파일 수집 (Source File Collector)\n   - Java AST 파싱 (Java AST Parser)\n   - XML Mapper 파싱 (XML Mapper Parser)\n   - Call Graph 생성 (Call Graph Builder)\n   - 결과 저장 (Data Persistence Layer)\n   - 진행 상황 표시 및 완료 메시지 출력\n\n2. list 명령어:\n   - list --all: 수집된 모든 소스 파일 목록 출력 (테이블 형식)\n   - list --db: 테이블별 접근 파일 목록 출력 (테이블 형식)\n   - list --modified: 수정된 파일 목록 출력 (테이블 형식)\n   - list --endpoint: REST API 엔드포인트 목록 출력 (테이블 형식)\n   - list --callgraph <endpoint>: 특정 엔드포인트의 호출 그래프 출력 (트리 형식)\n\n3. modify 명령어:\n   - 설정 파일 로드\n   - DB 접근 파일 식별 (DB Access Analyzer)\n   - 파일별 암복호화 코드 삽입 (Code Modifier)\n   - 수정 내역 저장\n   - 수정 완료 메시지 및 수정 파일 목록 출력\n   - --dry-run 옵션: 실제 수정 없이 미리보기\n\n구현 시 고려사항:\n- 각 명령어는 독립적인 함수로 구현\n- 결과 포맷팅: 테이블(tabulate), JSON, 트리 구조(anytree) 사용\n- 에러 처리: 각 단계에서 발생 가능한 에러 처리\n- 로깅: 모든 작업을 로그 파일에 기록\n- 타입 힌트: 명령 실행 결과 타입 명시\n- 한글 주석: 각 명령어 함수에 주석 추가",
        "testStrategy": "통합 테스트(pytest)를 작성하여 다음을 검증합니다:\n1. analyze 명령어 전체 워크플로우 확인\n2. list --all 명령어 출력 확인\n3. list --db 명령어 출력 확인\n4. list --modified 명령어 출력 확인\n5. list --endpoint 명령어 출력 확인\n6. list --callgraph 명령어 출력 확인\n7. modify 명령어 전체 워크플로우 확인\n8. modify --dry-run 옵션 확인\n9. 에러 처리 및 로깅 확인\n10. 대규모 프로젝트 시뮬레이션 테스트\n\n테스트 데이터: 완전한 테스트 Java Spring Boot 프로젝트 생성",
        "priority": "high",
        "dependencies": [
          3,
          4,
          7,
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "analyze 명령어 전체 워크플로우 구현",
            "description": "설정 파일 로드부터 결과 저장까지 analyze 명령어의 완전한 워크플로우를 구현합니다. Configuration Manager, Source File Collector, Java AST Parser, XML Mapper Parser, Call Graph Builder, Data Persistence Layer를 순차적으로 호출하고 진행 상황을 표시합니다.",
            "dependencies": [
              3,
              4,
              5,
              6,
              7
            ],
            "details": "analyze 명령어 함수 구현: 설정 파일 로드 → 소스 파일 수집 → Java AST 파싱 → XML Mapper 파싱 → Call Graph 생성 → 결과 저장. 각 단계에서 에러 처리 및 진행 상황 로깅. 타입 힌트 명시 및 한글 주석 추가. 대규모 프로젝트 처리 시 메모리 효율성 고려.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 analyze 명령어 전체 워크플로우 테스트: 설정 파일 로드 확인, 소스 파일 수집 확인, AST 파싱 결과 확인, Call Graph 생성 확인, 결과 저장 확인, 진행 상황 표시 확인"
          },
          {
            "id": 2,
            "title": "list --all 명령어 구현",
            "description": "수집된 모든 소스 파일 목록을 테이블 형식으로 출력하는 list --all 명령어를 구현합니다. Data Persistence Layer에서 파일 정보를 조회하고 tabulate 라이브러리를 사용하여 테이블 형식으로 포맷팅합니다.",
            "dependencies": [
              1
            ],
            "details": "list --all 명령어 함수 구현: 저장된 소스 파일 정보 조회 → 파일명, 경로, 크기, 수정 시간 등 메타데이터 추출 → tabulate로 테이블 형식 포맷팅 → 콘솔 출력. 파일 개수 요약 정보 포함. 에러 처리 및 로깅 추가.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 list --all 명령어 테스트: 파일 정보 조회 확인, 테이블 형식 출력 확인, 메타데이터 정확성 확인, 빈 결과 처리 확인"
          },
          {
            "id": 3,
            "title": "list --db 명령어 구현",
            "description": "테이블별 접근 파일 목록을 테이블 형식으로 출력하는 list --db 명령어를 구현합니다. DB Access Analyzer 결과를 조회하여 각 테이블에 접근하는 파일들을 그룹화하고 테이블 형식으로 출력합니다.",
            "dependencies": [
              1,
              8
            ],
            "details": "list --db 명령어 함수 구현: DB 접근 정보 조회 → 테이블별로 파일 그룹화 → 각 테이블별 접근 파일 목록 생성 → tabulate로 테이블 형식 포맷팅 → 콘솔 출력. 테이블명, 접근 파일 수, 파일 목록 포함. 에러 처리 및 로깅.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 list --db 명령어 테스트: DB 접근 정보 조회 확인, 테이블별 그룹화 확인, 테이블 형식 출력 확인, 다중 테이블 처리 확인"
          },
          {
            "id": 4,
            "title": "list --modified 명령어 구현",
            "description": "암복호화 코드가 삽입된 수정된 파일 목록을 테이블 형식으로 출력하는 list --modified 명령어를 구현합니다. Code Modifier에서 생성한 수정 기록을 조회하여 수정된 파일 정보를 테이블로 표시합니다.",
            "dependencies": [
              1
            ],
            "details": "list --modified 명령어 함수 구현: 수정 기록 조회 → 수정된 파일 정보 추출 (파일명, 수정 시간, 수정 내용 요약) → tabulate로 테이블 형식 포맷팅 → 콘솔 출력. 수정된 파일 개수 요약 정보 포함. 에러 처리 및 로깅.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 list --modified 명령어 테스트: 수정 기록 조회 확인, 파일 정보 추출 확인, 테이블 형식 출력 확인, 수정 내용 요약 정확성 확인"
          },
          {
            "id": 5,
            "title": "list --endpoint 명령어 구현",
            "description": "REST API 엔드포인트 목록을 테이블 형식으로 출력하는 list --endpoint 명령어를 구현합니다. Call Graph Builder에서 식별한 엔드포인트 정보를 조회하여 HTTP 메서드, 경로, 메서드명 등을 테이블로 표시합니다.",
            "dependencies": [
              1,
              7
            ],
            "details": "list --endpoint 명령어 함수 구현: 엔드포인트 정보 조회 → HTTP 메서드, 경로, 메서드명, 클래스명 추출 → tabulate로 테이블 형식 포맷팅 → 콘솔 출력. 엔드포인트 개수 요약 정보 포함. 에러 처리 및 로깅.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 list --endpoint 명령어 테스트: 엔드포인트 정보 조회 확인, HTTP 메서드 정확성 확인, 테이블 형식 출력 확인, 다중 엔드포인트 처리 확인"
          },
          {
            "id": 6,
            "title": "list --callgraph 명령어 구현",
            "description": "특정 엔드포인트의 호출 그래프를 트리 형식으로 출력하는 list --callgraph 명령어를 구현합니다. Call Graph Builder의 결과를 조회하여 엔드포인트부터 시작하는 호출 체인을 트리 구조로 시각화합니다.",
            "dependencies": [
              1,
              7
            ],
            "details": "list --callgraph <endpoint> 명령어 함수 구현: 엔드포인트 매개변수 파싱 → Call Graph에서 호출 체인 조회 → anytree를 사용하여 트리 구조 생성 → 트리 형식으로 콘솔 출력. 각 노드에 메서드명, 클래스명, 레이어 정보 포함. 에러 처리 및 로깅.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 list --callgraph 명령어 테스트: 엔드포인트 조회 확인, 호출 체인 추적 확인, 트리 형식 출력 확인, 순환 참조 처리 확인"
          },
          {
            "id": 7,
            "title": "modify 명령어 전체 워크플로우 구현",
            "description": "DB 접근 파일 식별부터 암복호화 코드 삽입까지 modify 명령어의 완전한 워크플로우를 구현합니다. DB Access Analyzer와 Code Modifier를 순차적으로 호출하고 수정 결과를 저장 및 출력합니다.",
            "dependencies": [
              1,
              8
            ],
            "details": "modify 명령어 함수 구현: 설정 파일 로드 → DB 접근 파일 식별 → 파일별 암복호화 코드 삽입 → 수정 내역 저장 → 수정 완료 메시지 및 수정 파일 목록 출력. 각 단계에서 에러 처리 및 진행 상황 로깅. 타입 힌트 명시 및 한글 주석 추가.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 modify 명령어 전체 워크플로우 테스트: 설정 파일 로드 확인, DB 접근 파일 식별 확인, 암복호화 코드 삽입 확인, 수정 내역 저장 확인, 완료 메시지 출력 확인"
          },
          {
            "id": 8,
            "title": "--dry-run 옵션 구현",
            "description": "modify 명령어의 --dry-run 옵션을 구현하여 실제 파일 수정 없이 미리보기 기능을 제공합니다. 수정될 코드를 미리 확인할 수 있도록 임시 메모리에서 처리하고 결과를 출력합니다.",
            "dependencies": [
              7
            ],
            "details": "--dry-run 옵션 구현: modify 명령어에 --dry-run 플래그 추가 → 실제 파일 쓰기 대신 메모리에서 처리 → 수정될 코드 미리보기 출력 → 파일 시스템 변경 없음 보장. 수정 전후 코드 비교 표시. 에러 처리 및 로깅.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 --dry-run 옵션 테스트: 파일 시스템 변경 없음 확인, 미리보기 출력 확인, 수정 전후 코드 비교 확인, 실제 modify와 동일한 결과 확인"
          },
          {
            "id": 9,
            "title": "결과 포맷팅, 에러 처리, 로깅 통합",
            "description": "모든 CLI 명령어에 대해 일관된 결과 포맷팅(tabulate, JSON, anytree), 포괄적인 에러 처리, 상세한 로깅을 통합합니다. 사용자 경험을 향상시키고 디버깅을 용이하게 합니다.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8
            ],
            "details": "결과 포맷팅: tabulate로 테이블 형식, JSON 직렬화, anytree로 트리 형식 통일. 에러 처리: 각 단계에서 발생 가능한 예외 처리, 사용자 친화적 에러 메시지 제공. 로깅: 모든 작업을 로그 파일에 기록, 로그 레벨 구분 (DEBUG, INFO, WARNING, ERROR). 타입 힌트 명시 및 한글 주석 추가.",
            "status": "done",
            "testStrategy": "pytest를 사용하여 포맷팅, 에러 처리, 로깅 통합 테스트: 테이블 형식 출력 확인, JSON 직렬화 확인, 트리 형식 출력 확인, 다양한 에러 상황 처리 확인, 로그 파일 생성 및 내용 확인"
          }
        ]
      },
      {
        "id": 11,
        "title": "CodeModifier 모듈 구현 및 LLM 기반 소스 코드 자동 수정",
        "description": "환경 설정 파일의 테이블/칼럼 정보를 기반으로 DB 접근 소스 파일을 식별하고, LLM(watsonx.ai, OpenAI, Claude.ai)을 활용하여 k-sign.CryptoService의 encrypt/decrypt 메서드 호출을 자동으로 삽입하여 DB 저장 시 암호화, 읽기 시 복호화되도록 소스 코드를 수정하는 CodeModifier 모듈을 구현합니다.",
        "details": "CodeModifier 모듈 구현 상세 사항:\n\n1. LLM 프로바이더 추상화:\n   - LLMProvider 추상 클래스 정의 (watsonx.ai, OpenAI, Claude.ai 지원)\n   - 각 LLM 프로바이더별 구현체 작성 (WatsonxProvider, OpenAIProvider, ClaudeProvider)\n   - 프로바이더 팩토리 패턴으로 설정에 따라 동적 선택\n   - API 키 관리 및 보안 처리\n\n2. 프롬프트 템플릿 설계:\n   - 명확한 지시사항: 암호화/복호화 대상 테이블/칼럼 명시\n   - 소스 코드 구조 분석: DAO/Mapper 레이어 식별 및 수정 위치 지정\n   - k-sign.CryptoService 메서드 호출 패턴 제시\n   - 수정 규칙: INSERT/UPDATE 시 암호화, SELECT 시 복호화\n   - 예제 코드 포함: 수정 전/후 비교 예시\n   - 프롬프트 변수화: 테이블명, 칼럼명, 클래스명 등 동적 치환\n\n3. 소스 코드 분석 및 수정 대상 식별:\n   - TableAccessInfo 데이터 활용: 테이블별 접근 파일 목록 조회\n   - 파일 레이어 분류: Mapper XML, DTO, DAO, Service 파일 구분\n   - 수정 대상 우선순위: Mapper XML → DAO → Service 순서\n   - 의존성 추적: 수정된 파일의 상위 레이어 파일도 함께 수정 필요 여부 판단\n\n4. LLM 호출 및 응답 처리:\n   - 배치 처리: 여러 파일을 한 번에 처리하거나 파일별로 개별 처리\n   - 토큰 제한 관리: 프롬프트 + 소스 코드 크기가 토큰 제한을 초과하지 않도록 분할\n   - 응답 파싱: LLM이 반환한 수정된 코드 추출 (마크다운 코드 블록 처리)\n   - 에러 처리: API 오류, 타임아웃, 토큰 초과 등 재시도 로직\n\n5. 코드 검증 및 안전성:\n   - 문법 검증: 수정된 Java/XML 코드의 기본 문법 검증\n   - 임포트 문 추가: CryptoService 임포트 자동 추가\n   - 변수명 충돌 검사: 기존 변수명과 충돌 여부 확인\n   - 롤백 기능: 수정 실패 시 원본 파일 복구\n\n6. 파일 수정 및 저장:\n   - 백업 생성: 원본 파일 백업 저장 (.bak 파일)\n   - 원자성 보장: 파일 쓰기 실패 시 롤백\n   - 메타데이터 보존: 파일 권한, 타임스탬프 유지\n   - 수정 로그 기록: 수정된 파일, 수정 내용, 타임스탬프 기록\n\n7. 설정 통합:\n   - 암호화 대상 테이블/칼럼 정보 활용\n   - LLM 프로바이더 선택 설정\n   - 프롬프트 템플릿 커스터마이징 옵션\n   - 드라이 런 모드: 실제 파일 수정 없이 미리보기\n\n구현 시 고려사항:\n- Strategy Pattern: LLM 프로바이더별 처리 분리\n- Template Method Pattern: 공통 수정 프로세스 정의\n- 에러 처리: 부분 실패 시에도 성공한 파일은 저장\n- 로깅: 상세한 디버그 로그 기록\n- 성능: 대규모 프로젝트 처리 시 병렬 처리 고려\n- 보안: API 키 환경 변수 관리, 민감 정보 로그 제외",
        "testStrategy": "CodeModifier 모듈 테스트 전략:\n\n1. 단위 테스트(pytest):\n   - LLM 프로바이더 추상화 테스트:\n     * 각 프로바이더(watsonx.ai, OpenAI, Claude.ai) 초기화 확인\n     * API 호출 모킹(mock)하여 응답 처리 검증\n     * 토큰 제한 초과 시 분할 처리 확인\n   \n   - 프롬프트 템플릿 테스트:\n     * 템플릿 변수 치환 정확성 확인\n     * 테이블/칼럼 정보 정확히 포함되는지 확인\n     * 예제 코드 포함 여부 확인\n   \n   - 코드 분석 및 수정 대상 식별 테스트:\n     * TableAccessInfo에서 올바른 파일 목록 조회 확인\n     * 파일 레이어 분류 정확성 확인\n     * 의존성 추적 정확성 확인\n   \n   - 응답 파싱 테스트:\n     * 마크다운 코드 블록 추출 확인\n     * 다양한 LLM 응답 형식 처리 확인\n     * 파싱 실패 시 에러 처리 확인\n   \n   - 코드 검증 테스트:\n     * Java 문법 검증 확인\n     * XML 문법 검증 확인\n     * 임포트 문 자동 추가 확인\n     * 변수명 충돌 감지 확인\n\n2. 통합 테스트:\n   - 전체 워크플로우 테스트:\n     * 설정 파일 로드 → 파일 식별 → LLM 호출 → 코드 수정 → 파일 저장 전체 프로세스 검증\n     * 실제 테스트 프로젝트에서 DB 접근 코드 수정 확인\n   \n   - 다양한 시나리오 테스트:\n     * 단일 테이블 단일 칼럼 암호화\n     * 다중 테이블 다중 칼럼 암호화\n     * 복잡한 JOIN 쿼리 처리\n     * 저장 프로시저 호출 처리\n   \n   - 에러 처리 테스트:\n     * LLM API 오류 시 재시도 로직 확인\n     * 토큰 초과 시 분할 처리 확인\n     * 파일 쓰기 실패 시 롤백 확인\n     * 부분 실패 시 성공한 파일 저장 확인\n\n3. 코드 품질 테스트:\n   - 수정된 코드 정확성:\n     * 수정된 Java 코드 컴파일 가능 여부 확인\n     * 수정된 XML 파일 파싱 가능 여부 확인\n     * 암호화/복호화 로직 정확성 확인\n   \n   - 백업 및 복구 테스트:\n     * 백업 파일 생성 확인\n     * 수정 실패 시 원본 복구 확인\n     * 메타데이터 보존 확인\n\n4. 성능 테스트:\n   - 대규모 프로젝트 처리:\n     * 100개 이상의 파일 수정 시 성능 측정\n     * 메모리 사용량 모니터링\n     * 병렬 처리 효율성 검증\n\n5. 드라이 런 모드 테스트:\n   - 실제 파일 수정 없이 미리보기 확인\n   - 수정 예상 내용 정확성 검증\n\n테스트 데이터:\n- 다양한 DB 접근 패턴을 포함한 테스트 프로젝트\n- 단순 SELECT/INSERT/UPDATE/DELETE 쿼리\n- 복잡한 JOIN, 서브쿼리 포함 쿼리\n- 저장 프로시저 호출\n- 다양한 암호화 대상 테이블/칼럼 조합",
        "status": "pending",
        "dependencies": [
          1,
          8,
          10
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "LLM 프로바이더 추상화 및 구현",
            "description": "LLMProvider 추상 클래스를 정의하고 watsonx.ai, OpenAI, Claude.ai 프로바이더 구현체를 작성합니다.",
            "dependencies": [],
            "details": "LLMProvider 추상 클래스 정의, WatsonxProvider/OpenAIProvider/ClaudeProvider 구현체 작성, 프로바이더 팩토리 패턴 구현, API 키 환경 변수 관리 및 보안 처리, 각 프로바이더별 API 호출 로직 구현",
            "status": "pending",
            "testStrategy": "각 프로바이더 초기화 테스트, API 호출 모킹 테스트, 토큰 제한 초과 시 분할 처리 테스트"
          },
          {
            "id": 2,
            "title": "프롬프트 템플릿 설계 및 변수화",
            "description": "암호화/복호화 대상 테이블/칼럼 명시, DAO/Mapper 레이어 식별, k-sign.CryptoService 호출 패턴을 포함한 프롬프트 템플릿을 설계합니다.",
            "dependencies": [
              1
            ],
            "details": "명확한 지시사항 작성, 소스 코드 구조 분석 가이드 포함, k-sign.CryptoService 메서드 호출 패턴 제시, INSERT/UPDATE/SELECT 수정 규칙 정의, 수정 전/후 예제 코드 작성, 테이블명/칼럼명/클래스명 동적 치환 변수화",
            "status": "pending",
            "testStrategy": "템플릿 변수 치환 정확성 테스트, 테이블/칼럼 정보 포함 확인, 예제 코드 포함 여부 검증"
          },
          {
            "id": 3,
            "title": "소스 코드 분석 및 수정 대상 식별",
            "description": "TableAccessInfo 데이터를 활용하여 파일 레이어를 분류하고 수정 대상을 우선순위에 따라 식별합니다.",
            "dependencies": [
              2
            ],
            "details": "TableAccessInfo 데이터 활용, Mapper XML/DTO/DAO/Service 파일 레이어 분류, 수정 대상 우선순위 결정(Mapper XML → DAO → Service), 의존성 추적으로 상위 레이어 파일 수정 필요 여부 판단, 파일 접근 정보 조회 및 분석",
            "status": "pending",
            "testStrategy": "파일 레이어 분류 정확성 테스트, 수정 대상 우선순위 검증, 의존성 추적 정확성 확인"
          },
          {
            "id": 4,
            "title": "LLM 호출 및 응답 처리 구현",
            "description": "배치 처리, 토큰 제한 관리, 응답 파싱, 에러 처리 및 재시도 로직을 구현합니다.",
            "dependencies": [
              3
            ],
            "details": "배치 처리 로직 구현(파일별 또는 일괄 처리), 토큰 제한 초과 시 프롬프트/코드 분할, LLM 응답에서 수정된 코드 추출(마크다운 코드 블록 처리), API 오류/타임아웃/토큰 초과 등 에러 처리, 지수 백오프 재시도 로직 구현",
            "status": "pending",
            "testStrategy": "배치 처리 동작 테스트, 토큰 제한 분할 처리 테스트, 응답 파싱 정확성 검증, 에러 처리 및 재시도 로직 테스트"
          },
          {
            "id": 5,
            "title": "코드 검증, 파일 수정 및 저장 기능 구현",
            "description": "수정된 코드의 문법 검증, 임포트 문 추가, 변수명 충돌 검사, 파일 백업 및 원자성 보장, 수정 로그 기록을 구현합니다.",
            "dependencies": [
              4
            ],
            "details": "Java/XML 코드 문법 검증, CryptoService 임포트 자동 추가, 기존 변수명과 충돌 검사, 원본 파일 백업(.bak 파일) 생성, 파일 쓰기 실패 시 롤백 기능, 파일 권한/타임스탬프 메타데이터 보존, 수정된 파일/내용/타임스탬프 로그 기록",
            "status": "pending",
            "testStrategy": "문법 검증 정확성 테스트, 임포트 문 추가 확인, 변수명 충돌 검사 테스트, 백업 생성 및 롤백 기능 검증, 로그 기록 정확성 확인"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-11-23T08:59:51.334Z",
      "updated": "2025-11-24T07:50:07.170Z",
      "description": "Tasks for master context"
    }
  }
}